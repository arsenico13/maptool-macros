#!/usr/bin/env python3
"""Reassemble a macro from parts


input:
   target -

       given macro/Single.xml and macro/Single.command exist

       target can be

       macro/Single
       macro/Single.xml
       macro/Single.command

       the path given needs to be relative to the current working directory

       Single.command belongs to
       Single.xml by virtue of the shared filename base and sharing the same
       directory

       Single.xml belongs to MyMacro.mtmacro by virtue of having a label
       attribute set to 'MyMacro'.  This can be overridden with the --output
       argument, below.

output:
   --output
       override output filename.  Default is to use the label from Single.xml
       plus the .mtmacro extension.

       Note: if the label has posix filesystem unfriendly characters they will
       be urlencoded.

   --verbose
   --quiet

       be more or less verbose

   --list <name>
       Instead of exporting the macros listed in target one at a time, create a
       single output file, by default called .mtmacset
"""

import io
import os
import sys
import argparse
from lxml import objectify
from lxml import etree
from zipfile import ZipFile, ZIP_DEFLATED
from zipfile_infolist import print_info
from urllib.parse import quote_plus as quote


AP = argparse.ArgumentParser()

AP.add_argument(
    'target',
    nargs='+',
    help="The path to the target xml.  If missing '.xml' we'll add it")

AP.add_argument(
    '--verbose',
    '-v',
    action='store_true',
    help="Print more verbose output")

AP.add_argument(
    '--quiet',
    '-q',
    action='store_true',
    help="Print less verbose output")

AP.add_argument(
    '--output-extension',
    help="override the output file extension, default='.mtmacro'",
    default='.mtmacro')

AP.add_argument(
    '--list',
    help="create a mtmacset (list of macros)")

opts = AP.parse_args(sys.argv[1:])

#define a properties.xml body for the final .mtmacro assembly
properties_xml="""<map>
  <entry>
    <string>version</string>
    <string>1.6.1</string>
  </entry>
</map>"""

# find the base path of the opts.target to construct the expected
# macro_filename and command_filename

class MTMacro():
    def __init__(self, target):
        self.target = target
        self.xml = None
        self.origxml = None
        self.command = None

        base,ext = os.path.splitext(target)
        self.xmlfile  = base + '.xml'
        self.commandfile = base + '.command'

        if opts.verbose:
            print('I: loading',mac.xmlfile,'for the macro xml file')
        self.origxml = objectify.parse(self.xmlfile)
        self.xml = objectify.parse(self.xmlfile)
        if opts.verbose:
            print('I: loading',self.commandfile,'for the macro command file')
        self.command = open(self.commandfile).read()
        # reassemble the command into the xml
        self.xml.getroot().command = objectify.DataElement(self.command, nsmap='', _pytype='')
        self.label = self.xml.getroot().label
        if opts.verbose:
            print('I: got label \"',label,'\" from the xml', sep='')
        self.label = quote(self.label.text)
        if opts.verbose and self.label != self.xml.getroot().label:
            print('I: transformed label to filesystem friendly',self.label)

        self.outputfile = self.label + opts.output_extension

    @property
    def root(self):
        if self.xml:
            return self.xml.getroot()
        else:
            return None

    def save(self):
        if self.xml and self.outputfile:
            if opts.verbose:
                print('I: using',self.outputfile,'as the output filename')

            # then assemble the zipfile
            zf = ZipFile(mac.outputfile, mode='w', compression=ZIP_DEFLATED)
            try:
                zf.writestr('content.xml',
                            etree.tostring(mac.xml, pretty_print=True))
                zf.writestr('properties.xml', properties_xml)
            finally:
                zf.close()
            if opts.verbose or not opts.quiet:
                print_info(mac.outputfile)

if opts.list:
    listxml = etree.Element('list')
    opts.output_extension = '.mtmacset'
for target in opts.target:
    mac = MTMacro(target)
    if not opts.list:
        mac.save()
    else:
        listxml.append(mac.xml.getroot())


if opts.list:
    output_filename = opts.list + opts.output_extension
    try:
        zf = ZipFile(output_filename, mode='w', compression=ZIP_DEFLATED)
        zf.writestr('content.xml', etree.tostring(listxml, pretty_print=True))
        zf.writestr('properties.xml', properties_xml)
    finally:
        zf.close()
        if opts.verbose or not opts.quiet:
            print_info(output_filename)
