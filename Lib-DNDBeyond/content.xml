<net.rptools.maptool.model.Token>
  <id>
    <baGUID>GdU5bb6ZScmytMapWjcJUw==</baGUID>
  </id>
  <beingImpersonated>false</beingImpersonated>
  <exposedAreaGUID>
    <baGUID>u+B1pmRVTLeErjvCpcdyOw==</baGUID>
  </exposedAreaGUID>
  <imageAssetMap>
    <entry>
      <null/>
      <net.rptools.lib.MD5Key>
        <id>7484f06dfd53c2ed50ec32035ae37a70</id>
      </net.rptools.lib.MD5Key>
    </entry>
  </imageAssetMap>
  <x>500</x>
  <y>300</y>
  <z>8</z>
  <anchorX>0</anchorX>
  <anchorY>0</anchorY>
  <sizeScale>1.0</sizeScale>
  <lastX>150</lastX>
  <lastY>600</lastY>
  <lastPath>
    <cellList class="linked-list">
      <net.rptools.maptool.client.walker.astar.AStarCellPoint>
        <x>3</x>
        <y>12</y>
        <g>0.0</g>
        <distanceTraveled>0.0</distanceTraveled>
        <distanceTraveledWithoutTerrain>0.0</distanceTraveledWithoutTerrain>
        <h>0.0</h>
        <f>0.0</f>
        <terrainModifier>0.0</terrainModifier>
        <validMoves/>
      </net.rptools.maptool.client.walker.astar.AStarCellPoint>
      <net.rptools.maptool.client.walker.astar.AStarCellPoint>
        <x>4</x>
        <y>11</y>
        <g>1.0</g>
        <distanceTraveled>1.0</distanceTraveled>
        <distanceTraveledWithoutTerrain>1.0</distanceTraveledWithoutTerrain>
        <parent>
          <x>3</x>
          <y>12</y>
          <g>0.0</g>
          <distanceTraveled>0.0</distanceTraveled>
          <distanceTraveledWithoutTerrain>0.0</distanceTraveledWithoutTerrain>
          <h>0.0</h>
          <f>0.0</f>
          <terrainModifier>0.0</terrainModifier>
          <validMoves reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint/validMoves"/>
        </parent>
        <h>6.001</h>
        <f>0.0</f>
        <terrainModifier>0.0</terrainModifier>
        <validMoves/>
      </net.rptools.maptool.client.walker.astar.AStarCellPoint>
      <net.rptools.maptool.client.walker.astar.AStarCellPoint>
        <x>5</x>
        <y>10</y>
        <g>2.0</g>
        <distanceTraveled>2.0</distanceTraveled>
        <distanceTraveledWithoutTerrain>2.0</distanceTraveledWithoutTerrain>
        <parent>
          <x>4</x>
          <y>11</y>
          <g>1.0</g>
          <distanceTraveled>1.0</distanceTraveled>
          <distanceTraveledWithoutTerrain>1.0</distanceTraveledWithoutTerrain>
          <parent reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint[2]/parent"/>
          <h>6.001</h>
          <f>0.0</f>
          <terrainModifier>0.0</terrainModifier>
          <validMoves reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint[2]/validMoves"/>
        </parent>
        <h>5.002</h>
        <f>0.0</f>
        <terrainModifier>0.0</terrainModifier>
        <validMoves/>
      </net.rptools.maptool.client.walker.astar.AStarCellPoint>
      <net.rptools.maptool.client.walker.astar.AStarCellPoint>
        <x>6</x>
        <y>9</y>
        <g>3.0</g>
        <distanceTraveled>3.0</distanceTraveled>
        <distanceTraveledWithoutTerrain>3.0</distanceTraveledWithoutTerrain>
        <parent>
          <x>5</x>
          <y>10</y>
          <g>2.0</g>
          <distanceTraveled>2.0</distanceTraveled>
          <distanceTraveledWithoutTerrain>2.0</distanceTraveledWithoutTerrain>
          <parent reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint[3]/parent"/>
          <h>5.002</h>
          <f>0.0</f>
          <terrainModifier>0.0</terrainModifier>
          <validMoves reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint[3]/validMoves"/>
        </parent>
        <h>4.003</h>
        <f>0.0</f>
        <terrainModifier>0.0</terrainModifier>
        <validMoves/>
      </net.rptools.maptool.client.walker.astar.AStarCellPoint>
      <net.rptools.maptool.client.walker.astar.AStarCellPoint>
        <x>7</x>
        <y>9</y>
        <g>4.0</g>
        <distanceTraveled>4.0</distanceTraveled>
        <distanceTraveledWithoutTerrain>4.0</distanceTraveledWithoutTerrain>
        <parent>
          <x>6</x>
          <y>9</y>
          <g>3.0</g>
          <distanceTraveled>3.0</distanceTraveled>
          <distanceTraveledWithoutTerrain>3.0</distanceTraveledWithoutTerrain>
          <parent reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint[4]/parent"/>
          <h>4.003</h>
          <f>0.0</f>
          <terrainModifier>0.0</terrainModifier>
          <validMoves reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint[4]/validMoves"/>
        </parent>
        <h>3.003</h>
        <f>0.0</f>
        <terrainModifier>0.0</terrainModifier>
        <validMoves/>
      </net.rptools.maptool.client.walker.astar.AStarCellPoint>
      <net.rptools.maptool.client.walker.astar.AStarCellPoint>
        <x>8</x>
        <y>8</y>
        <g>5.0</g>
        <distanceTraveled>5.0</distanceTraveled>
        <distanceTraveledWithoutTerrain>5.0</distanceTraveledWithoutTerrain>
        <parent>
          <x>7</x>
          <y>9</y>
          <g>4.0</g>
          <distanceTraveled>4.0</distanceTraveled>
          <distanceTraveledWithoutTerrain>4.0</distanceTraveledWithoutTerrain>
          <parent reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint[5]/parent"/>
          <h>3.003</h>
          <f>0.0</f>
          <terrainModifier>0.0</terrainModifier>
          <validMoves reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint[5]/validMoves"/>
        </parent>
        <h>2.002</h>
        <f>0.0</f>
        <terrainModifier>0.0</terrainModifier>
        <validMoves/>
      </net.rptools.maptool.client.walker.astar.AStarCellPoint>
      <net.rptools.maptool.client.walker.astar.AStarCellPoint>
        <x>9</x>
        <y>7</y>
        <g>6.0</g>
        <distanceTraveled>6.0</distanceTraveled>
        <distanceTraveledWithoutTerrain>6.0</distanceTraveledWithoutTerrain>
        <parent>
          <x>8</x>
          <y>8</y>
          <g>5.0</g>
          <distanceTraveled>5.0</distanceTraveled>
          <distanceTraveledWithoutTerrain>5.0</distanceTraveledWithoutTerrain>
          <parent reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint[6]/parent"/>
          <h>2.002</h>
          <f>0.0</f>
          <terrainModifier>0.0</terrainModifier>
          <validMoves reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint[6]/validMoves"/>
        </parent>
        <h>1.001</h>
        <f>0.0</f>
        <terrainModifier>0.0</terrainModifier>
        <validMoves/>
      </net.rptools.maptool.client.walker.astar.AStarCellPoint>
      <net.rptools.maptool.model.CellPoint>
        <x>10</x>
        <y>6</y>
        <g>0.0</g>
        <distanceTraveled>7.0</distanceTraveled>
        <distanceTraveledWithoutTerrain>7.0</distanceTraveledWithoutTerrain>
      </net.rptools.maptool.model.CellPoint>
    </cellList>
    <waypointList class="linked-list">
      <net.rptools.maptool.client.walker.astar.AStarCellPoint>
        <x>3</x>
        <y>12</y>
        <g>0.0</g>
        <distanceTraveled>0.0</distanceTraveled>
        <distanceTraveledWithoutTerrain>0.0</distanceTraveledWithoutTerrain>
        <h>0.0</h>
        <f>0.0</f>
        <terrainModifier>0.0</terrainModifier>
        <validMoves reference="../../../cellList/net.rptools.maptool.client.walker.astar.AStarCellPoint/validMoves"/>
      </net.rptools.maptool.client.walker.astar.AStarCellPoint>
      <net.rptools.maptool.model.CellPoint>
        <x>10</x>
        <y>6</y>
        <g>0.0</g>
        <distanceTraveled>7.0</distanceTraveled>
        <distanceTraveledWithoutTerrain>7.0</distanceTraveledWithoutTerrain>
      </net.rptools.maptool.model.CellPoint>
    </waypointList>
  </lastPath>
  <snapToScale>true</snapToScale>
  <width>32</width>
  <height>32</height>
  <isoWidth>256</isoWidth>
  <isoHeight>256</isoHeight>
  <scaleX>1.0</scaleX>
  <scaleY>1.0</scaleY>
  <sizeMap>
    <entry>
      <java-class>net.rptools.maptool.model.HexGridHorizontal</java-class>
      <net.rptools.maptool.model.GUID>
        <baGUID>fwABAQllXDgBAAAAOAABAQ==</baGUID>
      </net.rptools.maptool.model.GUID>
    </entry>
    <entry>
      <java-class>net.rptools.maptool.model.SquareGrid</java-class>
      <net.rptools.maptool.model.GUID>
        <baGUID>fwABAc9lFSoFAAAAKgABAQ==</baGUID>
      </net.rptools.maptool.model.GUID>
    </entry>
  </sizeMap>
  <snapToGrid>true</snapToGrid>
  <isVisible>true</isVisible>
  <visibleOnlyToOwner>false</visibleOnlyToOwner>
  <vblColorSensitivity>-1</vblColorSensitivity>
  <alwaysVisibleTolerance>2</alwaysVisibleTolerance>
  <isAlwaysVisible>false</isAlwaysVisible>
  <name>Lib:DnDBeyond</name>
  <ownerType>0</ownerType>
  <tokenShape>SQUARE</tokenShape>
  <tokenType>NPC</tokenType>
  <layer>TOKEN</layer>
  <propertyType>Basic</propertyType>
  <tokenOpacity>1.0</tokenOpacity>
  <terrainModifier>0.0</terrainModifier>
  <terrainModifierOperation>NONE</terrainModifierOperation>
  <terrainModifiersIgnored>
    <net.rptools.maptool.model.Token_-TerrainModifierOperation>NONE</net.rptools.maptool.model.Token_-TerrainModifierOperation>
  </terrainModifiersIgnored>
  <isFlippedX>false</isFlippedX>
  <isFlippedY>false</isFlippedY>
  <sightType>Darkvision</sightType>
  <hasSight>true</hasSight>
  <notes>https://www.dndbeyond.com/profile/Biliruben/characters/9471826</notes>
  <gmNotes></gmNotes>
  <state>
    <entry>
      <string>Paralyzed</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Stunned</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Exhaustion 6</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Frightened</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Grappled</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Exhaustion 3</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Bloodied</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Exhaustion 2</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Exhaustion 5</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Exhaustion 4</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Exhaustion 1</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Charmed</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Petrified</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Unconcious</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Prone</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Hidden</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Invisible</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Disabled</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Other2</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Poisoned</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Other3</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Dead</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Other4</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Helpless</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Incapacitated</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Blinded</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Deafened</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Restrained</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Dying</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Other</string>
      <boolean>false</boolean>
    </entry>
  </state>
  <propertyMapCI>
    <store>
      <entry>
        <string>constitution</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Constitution</key>
          <value class="string">18</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>strength</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Strength</key>
          <value class="string">18</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>libversion</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>libversion</key>
          <value class="string">0.1</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>hp</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>HP</key>
          <value class="string">125</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>description</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Description</key>
          <value class="string">The best</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>character id</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Character ID</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>charisma</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Charisma</key>
          <value class="string">8</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>wisdom</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Wisdom</key>
          <value class="string">10</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>defense</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Defense</key>
          <value class="string">Lightening Resistance</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>dmgdie</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>dmgDie</key>
          <value class="string">6</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>oncampaignload</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>onCampaignLoad</key>
          <value class="string">true</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>dmgnumdice</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>dmgNumDice</key>
          <value class="string">1</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>elevation</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Elevation</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>ac</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>AC</key>
          <value class="string">18</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>israging</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>isRaging</key>
          <value class="string">1</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>initiative</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Initiative</key>
          <value class="string">1</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>dmgroll</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>dmgRoll</key>
          <value class="string">1d6</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>attackbonus</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>attackBonus</key>
          <value class="string">10</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>ragebonus</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>rageBonus</key>
          <value class="string">3</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>intelligence</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Intelligence</key>
          <value class="string">12</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>dexterity</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Dexterity</key>
          <value class="string">13</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>condition</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Condition</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>critbonus</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>critBonus</key>
          <value class="string">3</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>dmgbonus</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>dmgBonus</key>
          <value class="string">8</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>movement</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Movement</key>
          <value class="string">40 Move / 40 Swim</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
    </store>
  </propertyMapCI>
  <macroPropertiesMap>
    <entry>
      <int>3</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>04a7efa6-9cae-4c76-9f96-b9effe1868e6</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>3</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>
[h: setProperty (&quot;libversion&quot;, &quot;0.1&quot;)]

&lt;!-- sigh, instead of explicitly defining each one, just inspect the relevant groups and iterate them --&gt;
[h: macros = getMacros()]
[h: log.debug (&quot;macros: &quot; + macros)]
[h, foreach (macroName, macros), code: {
	[h, if (lastIndexOf (macroName, &quot;dndb_&quot;) &gt; -1), code: {
		[h: log.debug (&quot;Registering &quot; + macroName)]
		[h: defineFunction (macroName, macroName + &quot;@this&quot;)]
	}]
}]

&lt;pre&gt;[r: json.indent (getInfo (&quot;client&quot;), 3)]&lt;/pre&gt;</command>
        <label>DNDBeyond Campaign Init</label>
        <group></group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>6</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>d1006b6e-c265-4e19-9f38-4ccaca0994ed</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>6</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- Callers must pass in the character json themselves. No getter methods should shoulder the --&gt;
&lt;!-- responsibility of calling dndb_getCharJSON --&gt;
[h: toon = arg(0)]

&lt;!-- AttackJSON constants --&gt;
[h: ATTACK_JSON = &quot;attackJSON&quot;]
[h: JSON_NAME = &quot;name&quot;]
[h: ATK_BONUS = &quot;atkBonus&quot;]
[h: DMG_BONUS = &quot;dmgBonus&quot;]
[h: DMG_DIE = &quot;dmgDie&quot;]
[h: DMG_DICE = &quot;dmgDice&quot;]

&lt;!-- Crit bonus dice is gonna be dodgey... Use Bode to see if theres a common json path--&gt;
[h: CRIT_BONUS_DICE = &quot;critBonusDice&quot;]
[h: DMG_TYPE = &quot;dmgType&quot;]
[h: DMG_BONUS_EXPR = &quot;dmgBonusExpr&quot;]

[h: attributes = dndb_getAbilities (toon)]
[h: proficiencyBonus = dndb_getProficiencyBonus (toon)]
[h: weapons = dndb_getWeapon (toon)]

&lt;!-- restrict to those that are equipped --&gt;
[h: weapons = json.path.read (weapons, &quot;.[?(@.equipped == &apos;true&apos;)]&quot;)]

[h: weapons = json.append (weapons, dndb_getUnarmedStrike (toon))]
&lt;!-- default to getting equipped weapons. Maybe we&apos;ll add an option later for full list.
&lt;!-- Fuck that, make getWeapons do it
&lt;!-- Defer attack and damage calculations to other macros. They need the work --&gt;

&lt;!-- get Rage feature --&gt;
[h: rageBonus = 0]
[h: ragefeatures = json.path.read (toon, &quot;data.classes..[?(@.definition.name == &apos;Rage&apos;)][&apos;levelScale&apos;]&quot;)]
[h, if (json.length (rageFeatures) &gt; 0): rageBonus = json.get (json.get (rageFeatures, 0), &quot;fixedValue&quot;)]

[h: attackJson = &quot;&quot;]
[h, foreach (weapon, weapons), code: {
	&lt;!-- does not include normal critical dice --&gt;
	[h: critBonusDice = dndb_getCriticalBonusDice (toon, weapon)]
	[h: weaponDmgBonus = dndb_getDamageModifierForWeapon (toon, weapon)]
	[h: weaponAtkBonus = dndb_getAttackModifierForWeapon (toon, weapon)]
	[h: critBonus = dndb_getCriticalBonusDice (toon, weapon)]
	[h: name = json.get (weapon, &quot;name&quot;)]
	&lt;!-- commas are scary --&gt;
	[h: name = replace (name, &quot;,&quot;, &quot; &quot;)]
	[h: attackJsonObj = json.set (&quot;&quot;, JSON_NAME, name,
			ATK_BONUS, weaponAtkBonus,
			DMG_BONUS, weaponDmgBonus,
			DMG_DIE, json.get (weapon, &quot;dmgDie&quot;),
			DMG_DICE, json.get (weapon, &quot;dmgDice&quot;),
			CRIT_BONUS_DICE, critBonus,
			DMG_TYPE, json.get (weapon, &quot;dmgType&quot;))]
	[h: attackJson = json.append (attackJson, attackJsonObj)]
	&lt;!-- Ragable? Make a rage version --&gt;
	[h, if (rageBonus &gt; 0 &amp;&amp; json.get (weapon, &quot;attackType&quot;) == &quot;Melee&quot;), code: {
		[h: attackJsonObj = json.set (attackJsonObj, 
			JSON_NAME, name + &quot; - Raging&quot;,
			DMG_BONUS, weaponDmgBonus + rageBonus)]
		[h: attackJson = json.append (attackJson, attackJsonObj)]
	}]
}]

[h: macro.return = attackJson]</command>
        <label>dndb_getAttackJSON</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>This is a function that requires the DND Beyond Character full JSON. It&apos;s not intended to run stand-alone.

This will pair with a separate class of macros centered around the property &apos;attackJSON&apos;. It will build this property from the class, inventory, and modifier information from the character JSON.</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>10</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>14de5160-5bc1-4197-a429-4d5c293c807c</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>10</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[r, macro (&quot;DNDBeyond Campaign Init@this&quot;): &quot;&quot;]</command>
        <label>onCampaignLoad</label>
        <group></group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>15</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>178cb065-a848-4794-8b54-9403ba53fffa</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>15</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- Callers must pass in the character json themselves. No getter methods should shoulder the --&gt;
&lt;!-- responsibility of calling dndb_getCharJSON --&gt;
&lt;!-- Requires two parameters: toon json and weapon object --&gt;
[h: toon = arg(0)]
[h: weapon = arg (1)]

[h: log.debug (&quot;dndb_getAttackModifierForWeapon&quot;)]

&lt;!-- Calculates attack bonus, including that which comes from the toon&apos;s attributes --&gt;
[h: attributes = dndb_getAbilities (toon)]
[h: strBonus = round (math.floor((json.get (attributes, &quot;str&quot;) - 10 ) / 2))]
[h: dexBonus = round (math.floor((json.get (attributes, &quot;dex&quot;) - 10 ) / 2))]
[h: finesseBonus = max (strBonus, dexBonus)]
[h: log.debug (&quot;strBonus: &quot; + strBonus + &quot; - dexBonus: &quot; + dexBonus + &quot; - finesseBonus&quot; + finesseBonus)]

[h, if (json.get (weapon, &quot;attackType&quot;) == &quot;Melee&quot;): abilityBonus = strBonus; abilityBonus = dexBonus]
[h: finesse = json.path.read (weapon, &quot;properties.[?(@.name == &apos;Finesse&apos;)]&quot;)]
[h, if (json.length (finesse) &gt; 0): abilityBonus = finesseBonus]
[h: totalAtkBonus = abilityBonus]
[h: log.debug (&quot;abilityBonus: &quot; + abilityBonus)]

&lt;!-- apply proficiency bonus --&gt;
[h: proficiencyBonus = dndb_getProficiencyBonus (toon)]
[h: proficient = json.get (weapon, &quot;proficient&quot;)]
[h, if (proficient &gt; 0): totalAtkBonus = totalAtkBonus + proficiencyBonus]
[h: log.debug (&quot;proficiencyBonus: &quot; + proficiencyBonus + &quot; - totalAtkBonus: &quot; + totalAtkBonus)]

[h: classAtkModifiers = json.path.read (toon, &quot;data.modifiers.class..[?(@.type == &apos;bonus&apos;)]&quot;)]

&lt;!-- WIP: we only know of some class abilities to parse --&gt;
[h, foreach (classAtkModifier, classAtkModifiers), code : {
	[h: bonus = json.get (classAtkModifier, &quot;value&quot;)]
	[h: qualified = dndb_isWeaponModifierApplicable (classAtkModifier, weapon)]
	[h: log.debug (json.indent (classAtkModifier, 3))]
	[h: log.debug (&quot;qualified: &quot; + qualified)]
	[h, if (qualified &gt; 0): totalAtkBonus = totalAtkBonus + bonus]
}]

[h: log.debug (&quot;totalAtkBonus after class: &quot; + totalAtkBonus)]
&lt;!-- no Race bonus to apply, yet. need a use case --&gt;


&lt;!-- apply item bonuses only if equipped --&gt;
[h: itemAtkModifiers = json.path.read (toon, &quot;data.modifiers.item..[?(@.type == &apos;bonus&apos;)]&quot;)]
&lt;!-- for ech itemDamageMod, get the componentId. Find the item in inventory with the matching id and check equipped --&gt;
[h, foreach (itemAtkModifier, itemAtkModifiers), code: {
	[h: qualified = dndb_isWeaponModifierApplicable (itemAtkModifier, weapon)]
	[h: log.debug (json.indent (itemAtkModifier, 3))]
	[h: log.debug (&quot;qualified: &quot; + qualified)]
	
	[h: componentId = json.get (itemAtkModifier, &quot;componentId&quot;)]
	[h: items = json.path.read (toon, &quot;data.inventory..[?(@.definition.id == &apos;&quot; + componentId + &quot;&apos;)]&quot;)]
	&lt;!-- should only be one --&gt;
	[h: item = json.get (items, 0)]
	[h: bonus = json.get (itemAtkModifier, &quot;value&quot;)]
	[h: equipped = json.get (item, &quot;equipped&quot;)]
	[h, if (equipped != &quot;true&quot;): qualified = 0]
	[h: log.debug (&quot;Qualified after equipped: &quot; + qualified)]
	[h, if (qualified &gt; 0): totalAtkBonus = totalAtkBonus + bonus]
}]

[h: log.debug (&quot;totalAtkBonus after item: &quot; + totalAtkBonus)]

&lt;!-- finally, bonuses on the weapon itself. No check for equipped here. --&gt;
[h: bonus = json.get (weapon, &quot;bonus&quot;)]
[h: totalAtkBonus = totalAtkBonus + bonus]
[h: log.debug (&quot;totalAtkBonus after weapon bonus: &quot; + totalAtkBonus)]

[h: macro.return = totalAtkBonus]</command>
        <label>dndb_getAttackModifierForWeapon</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>16</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>5f9c813e-6f33-46d3-addc-959d716dfaae</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>16</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- Callers must pass in the character json themselves. No getter methods should shoulder the getCharJSON --&gt;
[h: character = arg(0)]

&lt;!-- Base stats --&gt;
[h: baseStr = json.path.read (character, &quot;data.stats[0].value&quot;)]
[h: baseDex = json.path.read (character, &quot;data.stats[1].value&quot;)]
[h: baseCon = json.path.read (character, &quot;data.stats[2].value&quot;)]
[h: baseInt = json.path.read (character, &quot;data.stats[3].value&quot;)]
[h: baseWis = json.path.read (character, &quot;data.stats[4].value&quot;)]
[h: baseCha = json.path.read (character, &quot;data.stats[5].value&quot;)]

&lt;!-- Bonus stats --&gt;
[h: bonusStr = replace (json.path.read (character, &quot;data.bonusStats[0].value&quot;), &quot;null&quot;, 0)]
[h: bonusDex = replace (json.path.read (character, &quot;data.bonusStats[1].value&quot;), &quot;null&quot;, 0)]
[h: bonusCon = replace (json.path.read (character, &quot;data.bonusStats[2].value&quot;), &quot;null&quot;, 0)]
[h: bonusInt = replace (json.path.read (character, &quot;data.bonusStats[3].value&quot;), &quot;null&quot;, 0)]
[h: bonusWis = replace (json.path.read (character, &quot;data.bonusStats[4].value&quot;), &quot;null&quot;, 0)]
[h: bonusCha = replace (json.path.read (character, &quot;data.bonusStats[5].value&quot;), &quot;null&quot;, 0)]

[h: baseStr = baseStr + bonusStr]
[h: baseDex = baseDex + bonusDex]
[h: baseCon = baseCon + bonusCon]
[h: baseInt = baseInt + bonusInt]
[h: baseWis = baseWis + bonusWis]
[h: baseCha = baseCha + bonusCha]

&lt;!-- Ability improvements --&gt;
[h: strBonuses = json.path.read (character, &quot;.[?(@.subType == &apos;strength-score&apos;)][&apos;fixedValue&apos;]&quot;)]
[h: dexBonuses = json.path.read (character, &quot;.[?(@.subType == &apos;dexterity-score&apos;)][&apos;fixedValue&apos;]&quot;)]
[h: conBonuses = json.path.read (character, &quot;.[?(@.subType == &apos;constitution-score&apos;)][&apos;fixedValue&apos;]&quot;)]
[h: intBonuses = json.path.read (character, &quot;.[?(@.subType == &apos;intelligence-score&apos;)][&apos;fixedValue&apos;]&quot;)]
[h: wisBonuses = json.path.read (character, &quot;.[?(@.subType == &apos;wisdom-score&apos;)][&apos;fixedValue&apos;]&quot;)]
[h: chaBonuses = json.path.read (character, &quot;.[?(@.subType == &apos;charisma-score&apos;)][&apos;fixedValue&apos;]&quot;)]

[h, foreach (strBonus, strBonuses): baseStr = baseStr + strBonus]
[h, foreach (dexBonus, dexBonuses): baseDex = baseDex + dexBonus]
[h, foreach (conBonus, conBonuses): baseCon = baseCon + conBonus]
[h, foreach (intBonus, intBonuses): baseInt = baseInt + intBonus]
[h, foreach (wisBonus, wisBonuses): baseWis = baseWis + wisBonus]
[h, foreach (chaBonus, chaBonuses): baseCha = baseCha + chaBonus]

&lt;!-- Get Override stats and replace base w/ those. Apply only non-zero values --&gt;
[h: overrideStr = json.path.read (character, &quot;data.overrideStats[0].value&quot;)]
[h: overrideDex = json.path.read (character, &quot;data.overrideStats[1].value&quot;)]
[h: overrideCon = json.path.read (character, &quot;data.overrideStats[2].value&quot;)]
[h: overrideInt = json.path.read (character, &quot;data.overrideStats[3].value&quot;)]
[h: overrideWis = json.path.read (character, &quot;data.overrideStats[4].value&quot;)]
[h: overrideCha = json.path.read (character, &quot;data.overrideStats[5].value&quot;)]

[h, if (isNumber (overrideStr)): baseStr = overrideStr]
[h, if (isNumber (overrideDex)): baseDex = overrideDex]
[h, if (isNumber (overrideCon)): baseCon = overrideCon]
[h, if (isNumber (overrideInt)): baseInt = overrideInt]
[h, if (isNumber (overrideWis)): baseWis = overrideWis]
[h, if (isNumber (overrideCha)): baseCha = overrideCha]

[h: attributes = json.set(&quot;&quot;, &quot;str&quot;, baseStr,
							&quot;strBonus&quot;, round (math.floor ((baseStr - 10) / 2)),
							&quot;dex&quot;, baseDex,
							&quot;dexBonus&quot;, round (math.floor ((baseDex - 10) / 2)),
							&quot;con&quot;, baseCon,
							&quot;conBonus&quot;, round (math.floor ((baseCon - 10) / 2)),
							&quot;int&quot;, baseInt,
							&quot;intBonus&quot;, round (math.floor ((baseInt - 10) / 2)),
							&quot;wis&quot;, baseWis,
							&quot;wisBonus&quot;, round (math.floor ((baseWis - 10) / 2)),
							&quot;cha&quot;, baseCha,
							&quot;chaBonus&quot;, round (math.floor ((baseCha - 10) / 2))
							)]
							
[h: log.debug (attributes)]
[h: macro.return = attributes]</command>
        <label>dndb_getAbilities</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>This is a function that requires the DND Beyond Character full JSON. It&apos;s not intended to run stand-alone.</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>17</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>f71b85f6-778c-44e5-a088-abf6401b9c2e</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>17</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>
[h: BASE_URL = &quot;https://character-service.dndbeyond.com/character/v3/character/&quot;]
[h: charId = json.get( macro.args, 0 )]


[h: charAt = lastIndexOf (charId, &quot;/&quot;)]


[h, if (charAt &gt; -1): charId = substring (charId, charAt + 1)]

[h: url = BASE_URL + charId]
[h: log.debug (&quot;char url: &quot; + url)]
[h: character = REST.get(url)]
[h: macro.return = character]</command>
        <label>dndb_getCharJSON</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Fetches the JSON package for the provided character number</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>19</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>0cd7a488-fe05-4178-85c7-f6363d8e7f36</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>19</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg(0)]
[h: weapon = arg(1)]

&lt;!-- only way we know how to do this is by looking for known features --&gt;
[h: bonusCritDice = 0]

&lt;!-- Savage Attacks --&gt;
[h: savageAttackFeatureArry = json.path.read (toon, &quot;data.race..[?(@.definition.name == &apos;Savage Attacks&apos;)]&quot;)]
[h, if (json.length (savageAttackFeatureArry) &gt; 0 &amp;&amp; json.get(weapon, &quot;attackType&quot;) == &quot;Melee&quot;): bonusCritDice = bonusCritDice + 1]

&lt;!-- Brutal Critical --&gt;
&lt;!-- Get the barbarian class --&gt;
[h: barbarianClassLevelArry = json.path.read (toon, &quot;data.classes..[?(@.definition.name == &apos;Barbarian&apos;)][&apos;level&apos;]&quot;)]

[h: barbarianClassLevel = 0]
[h, if (json.length (barbarianClassLevelArry) &gt; 0): barbarianClassLevel = json.get (barbarianClassLevelArry, 0)]

[h: brutalCrit = 0]
[h: log.debug (&quot;barbarianClassLevel [raw]: &quot; + barbarianClassLevel)]
[h, if (isNumber (barbarianClassLevel)): barbarianClassLevel = number (barbarianClassLevel); barbarianClassLevel = 0]
[h: log.debug (&quot;barbarianClassLevel [number]: &quot; + barbarianClassLevel)]
[h, if (barbarianClassLevel &gt;= 9): brutalCrit = 1]
[h, if (barbarianClassLevel &gt;= 13): brutalCrit = 2]
[h, if (barbarianClassLevel &gt;= 17): brutalCrit = 3]
[h, if (json.get (weapon, &quot;attackType&quot;) == &quot;Melee&quot;): bonusCritDice = bonusCritDice + brutalCrit]


[h: macro.return = bonusCritDice]</command>
        <label>dndb_getCriticalBonusDice</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Returns only the extra dice granted on a critical hit for the given weapon. Does not include the normal critical dice.
arg(0) - Toon
arg(1) - Weapon</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>20</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>31365094-c23b-4025-9da6-97c850251edb</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>20</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- Callers must pass in the character json themselves. No getter methods should shoulder the --&gt;
&lt;!-- responsibility of calling dndb_getCharJSON --&gt;
&lt;!-- Requires two parameters: toon json and weapon object --&gt;
[h: toon = arg(0)]
[h: weapon = arg (1)]

[h: bonusType = &quot;damage&quot;]

&lt;!-- Calculates attack bonus, including that which comes from the toon&apos;s attributes --&gt;
[h: attributes = dndb_getAbilities (toon)]
[h: strBonus = round (math.floor((json.get (attributes, &quot;str&quot;) - 10 ) / 2))]
[h: dexBonus = round (math.floor((json.get (attributes, &quot;dex&quot;) - 10 ) / 2))]
[h: finesseBonus = max (strBonus, dexBonus)]

[h, if (json.get (weapon, &quot;attackType&quot;) == &quot;Melee&quot;): abilityBonus = strBonus; abilityBonus = dexBonus]
[h: finesse = json.path.read (weapon, &quot;properties.[?(@.name == &apos;Finesse&apos;)]&quot;)]
[h, if (json.length (finesse) &gt; 0): abilityBonus = finesseBonus]

[h: totalBonus = abilityBonus]

[h: classModifiers = json.path.read (toon, &quot;data.modifiers.class..[?(@.type == &apos;&quot; + bonusType + &quot;&apos;)]&quot;)]

&lt;!-- WIP: we only know of some class abilities to parse --&gt;
[r, foreach (classModifier, classModifiers), code : {
	&lt;!-- Assume qualified and eliminate from there --&gt;

	[h: qualified = 1]
	[h: bonus = json.get (classModifier, &quot;value&quot;)]
	[h: qualified = dndb_isWeaponModifierApplicable (classModifier, weapon)]

	[h, if (qualified &gt; 0): totalBonus = totalBonus + bonus]
}]

&lt;!-- no qualification checks on Race, yet --&gt;
[h: raceDamageModifiers = json.path.read (toon, &quot;data.modifiers.race..[?(@.type == &apos;&quot; + bonusType + &quot;&apos;)]&quot;)]
[h, foreach (raceDamageModifier, raceDamageModifiers), code: {
	[h: bonus = json.get (raceDamageModifier, &quot;value&quot;]
	[h: totalDamageBonus = totalDamageBonus + bonus]
}]

&lt;!-- apply item bonuses only if equipped --&gt;
[h: itemModifiers = json.path.read (toon, &quot;data.modifiers.item..[?(@.type == &apos;&quot; + bonusType + &quot;&apos;)]&quot;)]
&lt;!-- for ech itemDamageMod, get the componentId. Find the item in inventory with the matching id and check equipped --&gt;
[h, foreach (itemModifier, itemModifiers), code: {
	&lt;!-- itemModifier may have attack specific sub-types --&gt;
	[h: qualified = dndb_isWeaponModifierApplicable (itemModifier, weapon)]
	[h: componentId = json.get (itemModifier, &quot;componentId&quot;)]
	[h: items = json.path.read (toon, &quot;data.inventory..[?(@.definition.id == &apos;&quot; + componentId + &quot;&apos;)]&quot;)]
	&lt;!-- should only be one --&gt;
	[h: item = json.get (items, 0)]
	[h: bonus = json.get (itemModifier, &quot;value&quot;)]
	[h: equipped = json.get (item, &quot;equipped&quot;)]
	[h, if (equipped != &quot;true&quot;): qualified = 0]

	[h, if (qualified &gt; 0): totalBonus = totalBonus + bonus]
}]

&lt;!-- finally, bonuses on the weapon itself --&gt;
[h: bonus = json.get (weapon, &quot;bonus&quot;)]
[h: totalBonus = totalBonus + bonus]

[h: macro.return = totalBonus]
</command>
        <label>dndb_getDamageModifierForWeapon</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>21</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>0f87feca-72de-4d20-ae3d-420a97dca62a</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>21</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- Callers must pass in the character json themselves. No getter methods should shoulder the --&gt;
&lt;!-- responsibility of calling dndb_getCharJSON --&gt;
[h: character = arg(0)]

[h: classArry = json.path.read (character, &quot;data.classes&quot;)]
&lt;!--Subtract by one for div operation --&gt;
[h: totalClassLevel = -1]
[h, foreach (classDef, classArry), code: {
	[h: totalClassLevel = totalClassLevel + json.get (classDef, &quot;level&quot;)]
}]
[h: profBase = round(math.floor(totalClassLevel / 4))]
&lt;!-- add one, viola --&gt;
[h: proficiency = profBase + 2]
[r: proficiency]
[h: macro.return = proficiency]</command>
        <label>dndb_getProficiencyBonus</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>This is a function that requires the DND Beyond Character full JSON. It&apos;s not intended to run stand-alone. Returns the proficiency bonus based on class level.</toolTip>
        <displayHotKey>false</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>22</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>d505d03c-6f6d-4129-a638-289402e3848d</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>22</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg(0)]

&lt;!-- Build it like our simplified weapon json --&gt;
&lt;!-- Do I need the toon? Maybe there are class mods that apply a damage die. --&gt;
[h: unarmedStrike = json.set (&quot;&quot;,
	&quot;name&quot;, &quot;Unarmed Strike&quot;,
	&quot;attackType&quot;, &quot;Melee&quot;,
	&quot;dmgDie&quot;, &quot;1&quot;,
	&quot;dmgDice&quot;, &quot;1&quot;,
	&quot;dmgType&quot;, &quot;Bludgeoning&quot;,
	&quot;bonus&quot;, &quot;0&quot;,
	&quot;range&quot;, &quot;5&quot;,
	&quot;longRange&quot;, &quot;5&quot;,
	&quot;type&quot;, &quot;Unarmed&quot;,
	&quot;properties&quot;, &quot;[]&quot;,
	&quot;proficient&quot;, &quot;1&quot;,
	&quot;isMonk&quot;, &quot;true&quot;)]

[h: macro.return = unarmedStrike]</command>
        <label>dndb_getUnarmedStrike</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>arg(0): toon -although currently unused</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>23</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>f31ae75b-20bb-49d8-b07a-333970bebedf</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>23</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg(0)]
[h: weaponArry = arg(1)]

[h: basicArry = &quot;[]&quot;]

&lt;!-- Get proficencies --&gt;
[h: proficiencies = json.path.read (toon, &quot;data.modifiers..[?(@.type == &apos;proficiency&apos;)]&quot;)]
&lt;!-- Get proficencies, just the two --&gt;
[h: allProficiencies = json.path.read (toon, &quot;data.modifiers..[?(@.type == &apos;proficiency&apos;)]&quot;)]
[h: weaponProficiencies = json.path.read (allProficiencies,
		&quot;.[?(@.subType in [&apos;simple-weapons&apos;, &apos;martial-weapons&apos;])]&quot;)]

[h, foreach (weaponRaw, weaponArry), code: {
	[h: equipped = json.path.read (weaponRaw, &quot;equipped&quot;)]
	[h: attackType = json.path.read (weaponRaw, &quot;definition.attackType&quot;)]
	[h: grantedModifiers = json.path.read (weaponRaw, &quot;definition.grantedModifiers&quot;)]
	[h: dmgType = json.path.read (weaponRaw, &quot;definition.damageType&quot;)]
	&lt;!-- cant imagine there&apos;s a weapon that grants multiple bonuses, but this is
		an array, so treat it like one even though it&apos;s just one.--&gt;
	[h: bonus = 0]
	[h, foreach (modifier, grantedModifiers), code: {
		[h: bonusType = json.get (modifier, &quot;type&quot;)]
		[h: weaponBonus = json.get (modifier, &quot;value&quot;)]
		[h, if (equals (bonusType, &quot;bonus&quot;) &gt; 0): bonus = bonus + weaponBonus; bonus = bonus]
		[h: dmgType = dmgType + &quot;, &quot; + json.get (modifier, &quot;subType&quot;)]
	}]

	&lt;!-- correlate weapon categoryId w/ weaponProficiency entityId --&gt;
	[h: proficiencyId = json.path.read (weaponRaw, &quot;definition.categoryId&quot;)]
	[h: proficientArry = json.path.read (weaponProficiencies, 
		&quot;.[?(@.entityId == &apos;&quot; + proficiencyId + &quot;&apos;)]&quot;)]
	[h, if (attackType == &quot;1&quot;): attackTypeLabel = &quot;Melee&quot;; attackTypeLabel = &quot;Ranged&quot;]
	[h: dmgDie = json.path.read (weaponRaw, &quot;definition.damage.diceValue&quot;, &quot;SUPPRESS_EXCEPTIONS&quot;)]
	[h, if (dmgDie == &quot;null&quot;): dmgDie = 0]
	[h: dmgDice = json.path.read (weaponRaw, &quot;definition.damage.diceCount&quot;, &quot;SUPPRESS_EXCEPTIONS&quot;)]
	[h, if (dmgDice == &quot;null&quot;): dmgDice = 0]
	[h: basicWeapon = json.set (&quot;&quot;, &quot;name&quot;, json.path.read (weaponRaw, &quot;definition.name&quot;),
		&quot;attackType&quot;, attackTypeLabel,
		&quot;dmgDie&quot;, dmgDie,
		&quot;dmgDice&quot;, dmgDice,
		&quot;dmgType&quot;, dmgType,
		&quot;bonus&quot;, bonus,
		&quot;range&quot;, json.path.read (weaponRaw, &quot;definition.range&quot;),
		&quot;longRange&quot;, json.path.read (weaponRaw, &quot;definition.longRange&quot;),
		&quot;type&quot;, json.path.read (weaponRaw, &quot;definition.type&quot;),
		&quot;properties&quot;, json.path.read (weaponRaw, &quot;definition.properties&quot;),
		&quot;proficient&quot;, json.length (proficientArry),
		&quot;isMonk&quot;, json.path.read (weaponRaw, &quot;definition.isMonkWeapon&quot;),
		&quot;equipped&quot;, equipped)
	)]

	&lt;!-- bleh, move this to the end so I can save a nested level of execution --&gt;
	[h: basicArry = json.append (basicArry, basicWeapon)]
}]
[h: macro.return = basicArry]</command>
        <label>dndb_convertWeapons</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>This is a function that requires the DND Beyond Character full JSON. It&apos;s not intended to run stand-alone. Returns a simplifed json object of the weapons. Optional boolean flag may be passed to direct if all or only equipped weapons are provided. Default behavior returns only equipped weapons.</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>24</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>b3c91d02-c2aa-45dc-bdea-868411096c0c</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>24</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- Primarily via the subType attribute of the modifier, determine if the weapon applies. --&gt;
&lt;!-- Originally written for weapons, but could be expanded to easily apply to any item --&gt;
[h: modifier = arg(0)]
[h: weapon = arg(1)]
&lt;!-- todo - add a third optional argument to change from an optimistic behavior to a pessimistic --&gt;

[h: qualified = 1]

[h: subType = json.get (modifier, &quot;subType&quot;)]

&lt;!-- if subType is blank, most of our work is pointless --&gt;
[h, if (json.length (subType) == 0): subType = &quot;&quot;]

[h: attackType = json.get (weapon, &quot;attackType&quot;)]

&lt;!-- subType must have &quot;weapon-attack&quot; or weapon-ish attack --&gt;
[h: weaponAttacks = lastIndexOf (subType, &quot;weapon-attack&quot;)]
[h: weaponAttacks = weaponAttacks + lastIndexOf (subType, &quot;melee-attack&quot;)]
[h: weaponAttacks = weaponAttacks + lastIndexOf (subType, &quot;range-attack&quot;)]
[h, if (weaponAttacks &lt; 0): qualified = 0]

&lt;!-- Ranged required? --&gt;
[h: isRangedModifier = lastIndexOf (subType, &quot;range&quot;)]
[h: isMeleeModifier = lastIndexOf (subType, &quot;melee&quot;)]
[h, if (isRangedModifier &gt; -1 &amp;&amp; equals (attackType, &quot;Melee&quot;)): qualified = 0]
[h, if (isMeleeModifier &gt; -1 &amp;&amp; equals (attackType, &quot;Ranged&quot;)): qualified = 0]

&lt;!-- one hand vs two hand restriction --&gt;
[h: twoHandedProperty = json.path.read (weapon, &quot;properties..[?(@.name == &apos;Two-Handed&apos;)]&quot;)]
[h: oneHandedRestriction = lastIndexOf (subType, &quot;one-handed&quot;)]
[h, if (oneHandedRestriction &gt; -1 &amp;&amp; json.length (twoHandedProperty) &gt; 0): qualified = 0]



[h: macro.return = qualified]</command>
        <label>dndb_isWeaponModifierApplicable</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Utility method that tests if a weapon applies to a given modifier. For instance, does the modifier to add 2 points of damage to weapons wielded in one hand apply to the passed in weapon, which may be two-handed.

[h: modifier = arg(0)]
[h: weapon = arg(1)]

Returns 0 (false) or 1 (true)

TODO: this could be refactored to test against any item instead of just weapons.</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>26</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>368dcb60-1124-4430-a782-af9d9fb41549</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>26</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg (0)]

&lt;!-- Create a dummy &quot;unarmed&quot; armor just to make the next everything easier --&gt;
[h: unarmored = json.set (&quot;&quot;, &quot;equipped&quot;, &quot;true&quot;,
	&quot;definition&quot;, json.set (&quot;&quot;, &quot;armorClass&quot;, 10,
				&quot;baseArmorName&quot;, &quot;Unarmored&quot;,
				&quot;filterType&quot;, &quot;Armor&quot;,
				&quot;name&quot;, &quot;Unarmored&quot;,
				&quot;stealthCheck&quot;, 1,
				&quot;armorTypeId&quot;, 1))]
&lt;!-- And a dummy &quot;noShield&quot; --&gt;
[h: noShield = json.set (&quot;&quot;, &quot;equipped&quot;, &quot;true&quot;,
	&quot;definition&quot;, json.set (&quot;&quot;, &quot;armorClass&quot;, 0,
				&quot;baseArmorName&quot;, &quot;No Shield&quot;,
				&quot;filterType&quot;, &quot;Shield&quot;,
				&quot;name&quot;, &quot;No Shield&quot;,
				&quot;stealthCheck&quot;, 1,
				&quot;armorTypeId&quot;, 4))]

&lt;!-- Get all armors and shields from inventory --&gt;
[h: allArmors = dndb_getArmor (toon)]

&lt;!-- Determine equipped armor --&gt;
[h: armors = json.path.read (allArmors, &quot;[*].[?(@.definition.armorTypeId != 4)]&quot;)]
&lt;!-- Select first equipped armor. log.warn if there are more --&gt;
[h: equippedArmors = json.path.read (armors, &quot;[*].[?(@.equipped == true)]&quot;)]
[h: equippedArmorNum = json.length (equippedArmors)]
[h, if (equippedArmorNum &gt; 1): log.warn (&quot;Too many armors equipped, selecting first found armor&quot;)]
[h, if (equippedArmorNum &gt; 0): equippedArmor = json.get(equippedArmors, 0); 
	equippedArmor = unarmored]
&lt;!-- adorn the armor with bonuses --&gt;
[h: equippedArmor = dndb_setArmorBonus (equippedArmor)]
[h: log.debug (&quot;Selecting equipped armor: &quot; + equippedArmor)]

&lt;!-- determine equipped shield --&gt;
[h: shields = json.path.read (allArmors, &quot;[*].[?(@.definition.armorTypeId == 4)]&quot;)]
&lt;!-- Select first equipped shield. log.warn if there are more --&gt;
[h: equippedShields = json.path.read (shields, &quot;[*].[?(@.equipped == true)]&quot;)]
[h: equippedShieldNum = json.length (equippedShields)]
[h, if (equippedShieldNum &gt; 1): log.warn (&quot;Too many shields equipped, selecting first found shield&quot;)]
[h, if (equippedShieldNum &gt; 0): equippedShield = json.get(equippedShields, 0); 
	equippedShield = noShield]
&lt;!-- adorn the shield with bonuses --&gt;
[h: equippedShield = dndb_setArmorBonus (equippedShield)]
[h: log.debug (&quot;Selecting equipped shield: &quot; + equippedShield)]

&lt;!-- Calculate Dexterity bonus --&gt;
[h: attributes = dndb_getAbilities (toon)]
[h: dexBonus = json.get (attributes, &quot;dexBonus&quot;)]

&lt;!-- Apply dex bonus --&gt;
&lt;!-- rules: --&gt;
&lt;!-- no or light armor: full dex bonus --&gt;
&lt;!-- medium armor: dex bonus, up to +2 --&gt;
&lt;!-- heavy armor: No dex bonus (positive or negative) --&gt;
[h: armorTypeId = json.path.read (equippedArmor, &quot;definition.armorTypeId&quot;)]
[h: log.debug (&quot;armorTypeId: &quot; + armorTypeId)]
[h, switch ( armorTypeId ):
	case &quot;1&quot; : dexBonus = dexBonus;
	case &quot;2&quot; : dexBonus = math.min (dexBonus, 2);
	case &quot;3&quot; : dexBonus = 0
]
[h: log.debug (&quot;dexBonus (calculated): &quot; + dexBonus)]

&lt;!-- Look for other modifiers from class abilities --&gt;
&lt;!-- Lets defer this to another script for brevity --&gt;
[h: classACBonus = dndb_getACBonusFromClasses (toon)]
[h: log.debug (&quot;classACBonus: &quot; + json.indent (classACBonus))]

&lt;!-- And build it --&gt;
&lt;!-- Lets recap the players --&gt;
&lt;!-- total: every thing --&gt;
&lt;!-- dexterity: dex bonus, modified --&gt;
&lt;!-- armor: just the equipped armor --&gt;
&lt;!-- shield: just the equipped shield --&gt;
&lt;!-- feature: whatever the feature is providing --&gt;
[h: armorBonus = json.get (equippedArmor, &quot;totalAC&quot;)]
[h: log.debug (&quot;armorBonus: &quot; + armorBonus)]
[h: shieldBonus = json.get (equippedShield, &quot;totalAC&quot;)]
[h: log.debug (&quot;shieldBonus: &quot; + shieldBonus)]
&lt;!-- calculate what we have so far --&gt;
[h: totalACBonus = armorBonus + shieldBonus + dexBonus]
&lt;!-- build the base object --&gt;
[h: acObj = json.set (&quot;&quot;, &quot;Dexterity&quot;, dexBonus,
		&quot;Armor&quot;, armorBonus,
		&quot;Shield&quot;, shieldBonus)]
&lt;!-- and the class features --&gt;
[h: totalClassACBonus = json.get (classACBonus, &quot;totalClassACBonus&quot;)]
[h: totalACBonus = totalACBonus + totalClassACBonus]
[h, foreach (classFeature, json.get (classACBonus, &quot;classFeatures&quot;)), code: {
	[h: classBonus = json.get (classFeature, &quot;dndb_bonus&quot;)]
	[h: featureName = json.path.read (classFeature, &quot;definition.name&quot;)]
	[h: acObj = json.set (acObj, featureName, classBonus)]
}]
&lt;!-- hope this added up correctly --&gt;
[h: acObj = json.set (acObj, &quot;total&quot;, totalACBonus)]
[h: macro.return = acObj]</command>
        <label>dndb_getAC</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Given a character, returns an object with all AC bonuses.

arg(0) : toon

returns acObj
(example)

{
	&quot;total&quot; : 18,
	&quot;Armor&quot; : 10,
	&quot;Dexterity&quot; : 1,
	&quot;Unarmored Bonus&quot; : 4,
	&quot;Shield&quot; : 3
}</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>27</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>572baa50-10b2-439b-87b8-5a751de36bb8</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>27</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: armor = arg(0)]
[h: log.debug (&quot;Getting AC for &quot; + json.path.read (armor, &quot;definition.name&quot;))]
[h: baseAC = json.path.read (armor, &quot;definition.armorClass&quot;)]
[h: log.debug (&quot;baseAC: &quot; + baseAc)]

[h: bonuses = json.path.read (armor, &quot;definition.grantedModifiers.[?(@.subType == &apos;armor-class&apos;)][&apos;value&apos;]&quot;, &quot;SUPPRESS_EXCEPTIONS,ALWAYS_RETURN_LIST&quot;)]
[h: log.debug (&quot;bonuses: &quot; + bonuses)]
[h: totalBonus = 0]
[h, foreach (bonus, bonuses): totalBonus = totalBonus + bonus]
[h: armor = json.set (armor, &quot;bonusAC&quot;, totalBonus, &quot;totalAC&quot;, baseAC + totalBonus)]

[h: macro.return = armor]</command>
        <label>dndb_setArmorBonus</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Utility method to calculate amor class bonuses from the input armor

arg(0) = armor

Return armor with bonus added

Ex. for +3 Shield
{
	&quot;equipped&quot; : true,
	&quot;definition&quot; : [..],
	&quot;bonusAC&quot;: 3
	&quot;totalAC&quot;: 5
}</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>28</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>50a2c364-985a-4e3a-8dd3-bbf9a520dc05</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>28</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg(0)]

[h: totalClassACBonus = 0]
[h: classFeatures = &quot;[]&quot;]
&lt;!-- Look for known features --&gt;

&lt;!-- Barbarian --&gt;
[h: barbarian = json.path.read (toon, &quot;data.classes[*].[?(@.definition.name == &apos;Barbarian&apos;)]&quot;)]
[h, if (json.length (barbarian) == 0): barbarian = &quot;{}&quot;]
[h: log.debug (&quot;barbarian: &quot; + json.length (barbarian))]
[h, if (json.length (barbarian) &gt; 0): barbarian = json.get (barbarian, 0)]

&lt;!-- Look for barbarian class feature &quot;Unarmored Defense&quot; --&gt;
[h: level = 0]
[h: unarmoredDefense = &quot;[]&quot;]
[h: level = json.get (barbarian, &quot;level&quot;)]
[h, if (level == &quot;&quot;): level = 0]
[h: log.debug (&quot;level: &quot; + level)]
[h, if (level &gt; 0), code: {
	[h: unarmoredDefense = json.path.read (barbarian,
			&quot;classFeatures[*].[?(@.definition.name == &apos;Unarmored Defense&apos;)]&quot;)]
	[h, if (json.length (unarmoredDefense) &gt; 0): unarmoredDefense = json.get (unarmoredDefense, 0)]
	[h: log.debug (&quot;unarmoredDefense: &quot; + json.indent (unarmoredDefense))]
}; {0}
]

[h, if (json.length (unarmoredDefense) &gt; 0), code: {
	&lt;!-- Confirm the barb isnt wearing armor (note: DND Beyond doesnt check this) --&gt;
	[h: equippedArmors = json.path.read (toon, &quot;data.inventory[*].[?(@.equipped == true &amp;&amp; @.definition.armorTypeId &lt; 4)]&quot;)]
	[h: totalEquipped = json.length (equippedArmors)]
	[h: log.debug (&quot;totalEquipped: &quot; + totalEquipped)]
	[h, if (totalEquipped == 0), code: {
		[h: attributes = dndb_getAbilities (toon)]
		[h: featureBonus = json.get (attributes, &quot;conBonus&quot;)]
		[h: totalClassACBonus = totalClassACBonus + featureBonus]
		&lt;!-- Tack on a bonus attribute: dndb_bonus --&gt;
		[h: unarmoredDefense = json.set (unarmoredDefense, &quot;dndb_bonus&quot;, featureBonus)]
		[h: classFeatures = json.append (classFeatures, unarmoredDefense)]
	}]
}]

&lt;!-- Build the return object --&gt;
[h: acBonuses = json.set (&quot;&quot;, &quot;totalClassACBonus&quot;, totalClassACBonus,
			&quot;classFeatures&quot;, classFeatures)]
[h: macro.return = acBonuses]</command>
        <label>dndb_getACBonusFromClasses</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Returns the AC Bonuses from class features

arg (0) = toon

returns bonusObj

ex.
{
	&quot;totalClassACBonus&quot; : 3,
	&quot;classFeatures&quot; : [ contributing class features ]
}</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>29</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>9d1783b5-7cde-46f2-85cb-f64bc7ebad4f</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>29</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg (0)]
[h: className = arg (1)]

[h: classObj = json.path.read (toon, &quot;data.classes[*].[?(@.definition.name == &apos;&quot; + className + &quot;&apos;)]&quot;)]

[h: macro.return = classObj]
</command>
        <label>dndb_getClass</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Returns the class object from the toon json.

arg(0) = toon
arg(1) = class name

returns class object found in toon&apos;s:

data.classes[]</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>30</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>64a40aad-4f95-4f5e-9702-7a920daa88f5</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>30</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- get toon and maybe a weapon name --&gt;
[h: toon = arg(0)]
[h, if (json.length (macro.args) &gt; 1):
				weapons = dndb_getInventory (toon, &quot;Weapon&quot;, arg(1)); 
				weapons = dndb_getInventory (toon, &quot;Weapon&quot;)]

[h: weapons = dndb_convertWeapons (toon, weapons)]

[h: macro.return = weapons]</command>
        <label>dndb_getWeapon</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Returns the requested weapon, or all wepons if none specified.

arg(0) = toon
optional: arg (1) = weapon name

Returns weapons in simplified format:
ex.
{
  &quot;name&quot;: &quot;Scimitar of Speed&quot;,
  &quot;attackType&quot;: &quot;Melee&quot;,
  &quot;dmgDie&quot;: 6,
  &quot;dmgDice&quot;: 1,
  &quot;dmgType&quot;: &quot;Slashing, magic&quot;,
  &quot;bonus&quot;: 2,
  &quot;range&quot;: 5,
  &quot;longRange&quot;: 5,
  &quot;type&quot;: &quot;Scimitar&quot;,
  &quot;properties&quot;:   [
        {
      &quot;description&quot;: &quot;When making an attack with a finesse weapon, you use your choice of your Strength or Dexterity modifier for the attack and damage rolls. You must use the same modifier for both rolls. &quot;,
      &quot;id&quot;: 2,
      &quot;name&quot;: &quot;Finesse&quot;
    },
        {
      &quot;description&quot;: &quot;A light weapon is small and easy to handle, making it ideal for use when fighting with two weapons. &quot;,
      &quot;id&quot;: 4,
      &quot;name&quot;: &quot;Light&quot;
    }
  ],
  &quot;proficient&quot;: 2,
  &quot;isMonk&quot;: &quot;false&quot;
}</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>31</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>d8191b89-89d3-4d8a-acd1-85b53de37b08</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>31</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- get toon and maybe a armor name --&gt;
[h: toon = arg(0)]
[h, if (json.length (macro.args) &gt; 1): 
				results = dndb_getInventory (toon, &quot;Armor&quot;, arg(1)); 
				results = dndb_getInventory (toon, &quot;Armor&quot;)]
[h: macro.return = results]</command>
        <label>dndb_getArmor</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Returns the requested armor, or all amors if none specified.

arg(0) = toon
optional: arg (1) = armor name

Returns armor without transformation:
ex.
{
    &quot;armorClass&quot;: 11,
    &quot;baseArmorName&quot;: &quot;Leather&quot;,
    &quot;baseItemId&quot;: 10,
    &quot;baseTypeId&quot;: 701257905,
    &quot;bundleSize&quot;: 1,
    &quot;canAttune&quot;: false,
    &quot;canEquip&quot;: true,
    &quot;cost&quot;: 10,
    &quot;description&quot;: &quot;The breastplate and shoulder protectors of this armor are made of leather that has been stiffened by being boiled in oil. The rest of the armor is made of softer and more flexible materials.&quot;,
    &quot;entityTypeId&quot;: 701257905,
    &quot;filterType&quot;: &quot;Armor&quot;,
    &quot;grantedModifiers&quot;: [],
    &quot;id&quot;: 10,
    &quot;isConsumable&quot;: false,
    &quot;isHomebrew&quot;: false,
    &quot;isMonkWeapon&quot;: false,
    &quot;isPack&quot;: false,
    &quot;magic&quot;: false,
    &quot;name&quot;: &quot;Leather&quot;,
    &quot;rarity&quot;: &quot;Common&quot;,
    &quot;stackable&quot;: false,
    &quot;stealthCheck&quot;: 1,
    &quot;tags&quot;: [],
    &quot;type&quot;: &quot;Light Armor&quot;,
    &quot;weaponBehaviors&quot;: [],
    &quot;weight&quot;: 10,
    &quot;sources&quot;: [],
    &quot;armorTypeId&quot;: 1,
    &quot;canBeAddedToInventory&quot;: true
}</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>32</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>15a3ebd6-91d5-42ac-ab16-e45e208851e4</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>32</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- get toon and maybe an item name --&gt;
[h: toon = arg(0)]
[h, if (json.length (macro.args) &gt; 1): 
				results = dndb_getInventory (toon, &quot;Other Gear&quot;, arg(1)); 
				results = dndb_getInventory (toon, &quot;Other Gear&quot;)]
[h: macro.return = results]</command>
        <label>dndb_getItem</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>33</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>ea018cb1-14cd-4417-a42b-5be005674ed7</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>33</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: log.debug (&quot;Entering getInventory&quot;)]

[h: toon = arg(0)]
[h: filterType = arg(1)]
[h, if (json.length (macro.args) &gt; 2): itemName = arg(2); itemName = &quot;_all&quot;]

[h: log.debug (json.get (toon, &quot;name&quot;))]
[h: log.debug (filterType)]

[h: inventoryArry = json.path.read (toon, &quot;data.inventory[*].[?(@.definition.filterType == &apos;&quot; + filterType + &quot;&apos;)]&quot;)]
[h: selectedItem = json.path.read (inventoryArry, &quot;.[?(@.name == &apos;&quot; + itemName + &quot;&apos;)]&quot;)]
[h, if (json.length (selectedItem) &gt; 0): 
		selectedItem = json.get (selectedItem, 0);
		selectedItem = &quot;{}&quot;]
[h: log.debug (&quot;selectedItem: &quot; + json.indent (selectedItem))]
[h, if (itemName == &quot;_all&quot;): macro.return = inventoryArry; macro.return = selectedItem]</command>
        <label>dndb_getInventory</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Returns an item or items. A filterType must be specified, but a name may be optional.

arg(0) = toon
arg(1) = filterType
optional: arg(2) = name

ex.
dnd_getInventory (toon, &quot;Other Gear&quot;, &quot;Backpack&quot;)

returns:
{
  &quot;baseTypeId&quot;: 2103445194,
  &quot;bundleSize&quot;: 1,
  &quot;canAttune&quot;: false,
  &quot;canEquip&quot;: false,
  &quot;cost&quot;: 2,
  &quot;description&quot;: &quot;A backpack&quot;,
  &quot;entityTypeId&quot;: 2103445194,
  &quot;filterType&quot;: &quot;Other Gear&quot;,
  &quot;grantedModifiers&quot;: [],
  &quot;id&quot;: 20,
  &quot;isConsumable&quot;: false,
  &quot;isHomebrew&quot;: false,
  &quot;isMonkWeapon&quot;: false,
  &quot;isPack&quot;: false,
  &quot;magic&quot;: false,
  &quot;name&quot;: &quot;Backpack&quot;,
  &quot;rarity&quot;: &quot;Common&quot;,
  &quot;stackable&quot;: true,
  &quot;subType&quot;: &quot;Adventuring Gear&quot;,
  &quot;tags&quot;: [&quot;Container&quot;],
  &quot;type&quot;: &quot;Gear&quot;,
  &quot;weaponBehaviors&quot;: [],
  &quot;weight&quot;: 5,
  &quot;sources&quot;: [],
  &quot;gearTypeId&quot;: 1,
  &quot;canBeAddedToInventory&quot;: true
}

</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>34</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>f1387c74-f57e-4dda-af64-5bb56d9cd08f</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>34</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg(0)]
[h, if (json.length (macro.args) &gt; 1): skillName = arg(1); skillName = &quot;_all&quot;]
&lt;!-- Constants --&gt;
&lt;!-- If we have to revisit skill searching, we may be able to convert the search from --&gt;
&lt;!-- change entityId to valueId to match up with the pattern in saving throw --&gt;
&lt;!-- entityId to typeId == 23 --&gt;
[h: SKILL_ENTITY_TYPE_ID = &quot;1958004211&quot;]

&lt;!-- oddly enough, toon has no base information for skills, only bonuses. So we have --&gt;
&lt;!-- to build it from scratch --&gt;
&lt;!-- oh fuck, the only thing in the toon to point to individual skills are jackass valueIds --&gt;
&lt;!-- So Ima need to map those, also --&gt;
[h: preSkills = json.append (&quot;&quot;,
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Acrobatics&quot;, &quot;ability&quot;, &quot;dex&quot;, &quot;entityId&quot;, &quot;3&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Animal Handling&quot;, &quot;ability&quot;, &quot;wis&quot;, &quot;entityId&quot;, &quot;11&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Arcana&quot;, &quot;ability&quot;, &quot;int&quot;, &quot;entityId&quot;, &quot;6&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Athletics&quot;, &quot;ability&quot;, &quot;str&quot;, &quot;entityId&quot;, &quot;2&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Deception&quot;, &quot;ability&quot;, &quot;cha&quot;, &quot;entityId&quot;, &quot;16&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;History&quot;, &quot;ability&quot;, &quot;int&quot;, &quot;entityId&quot;, &quot;7&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Insight&quot;, &quot;ability&quot;, &quot;wis&quot;, &quot;entityId&quot;, &quot;12&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Intimidation&quot;, &quot;ability&quot;, &quot;cha&quot;, &quot;entityId&quot;, &quot;17&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Investigation&quot;, &quot;ability&quot;, &quot;int&quot;, &quot;entityId&quot;, &quot;8&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Medicine&quot;, &quot;ability&quot;, &quot;wis&quot;, &quot;entityId&quot;, &quot;13&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Nature&quot;, &quot;ability&quot;, &quot;int&quot;, &quot;entityId&quot;, &quot;9&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Perception&quot;, &quot;ability&quot;, &quot;wis&quot;, &quot;entityId&quot;, &quot;14&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Performance&quot;, &quot;ability&quot;, &quot;cha&quot;, &quot;entityId&quot;, &quot;18&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Persuasion&quot;, &quot;ability&quot;, &quot;cha&quot;, &quot;entityId&quot;, &quot;19&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Religion&quot;, &quot;ability&quot;, &quot;int&quot;, &quot;entityId&quot;, &quot;10&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Sleight of Hand&quot;, &quot;ability&quot;, &quot;dex&quot;, &quot;entityId&quot;, &quot;4&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Stealth&quot;, &quot;ability&quot;, &quot;dex&quot;, &quot;entityId&quot;, &quot;5&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Survival&quot;, &quot;ability&quot;, &quot;wis&quot;, &quot;entityId&quot;, &quot;15&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Strength Ability&quot;, &quot;ability&quot;, &quot;str&quot;, &quot;entityId&quot;, &quot;dummyId&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Dexterity Ability&quot;, &quot;ability&quot;, &quot;dex&quot;, &quot;entityId&quot;, &quot;dummyId&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Constitution Ability&quot;, &quot;ability&quot;, &quot;con&quot;, &quot;entityId&quot;, &quot;dummyId&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Intelligence Ability&quot;, &quot;ability&quot;, &quot;int&quot;, &quot;entityId&quot;, &quot;dummyId&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Wisdom Ability&quot;, &quot;ability&quot;, &quot;wis&quot;, &quot;entityId&quot;, &quot;dummyId&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Charisma Ability&quot;, &quot;ability&quot;, &quot;cha&quot;, &quot;entityId&quot;, &quot;dummyId&quot;)
)]

[h: skills = &quot;[]&quot;]
[h, foreach (skill, preSkills), code: {
	[h, if (skillName == &quot;_all&quot; || skillName == json.get (skill, &quot;name&quot;)): skills = json.append (skills, skill)] 
}]

[h: data = json.get (toon, &quot;data&quot;)]
[h: dataRetains = json.append (&quot;&quot;, &quot;modifiers&quot;, &quot;inventory&quot;, &quot;classes&quot;, &quot;stats&quot;, &quot;bonusStats&quot;, &quot;overrideStats&quot;)]
[h: skinnyData = dndb_getSkinnyObject (data, dataRetains)]
&lt;!-- Skinnify the toon --&gt;
[h: fatToon = toon]
[h: toon = json.set (toon, &quot;data&quot;, skinnyData)]

&lt;!-- Lets call this the Rex Redrum bug: features that grant all ability checks some level of proficiency have --&gt;
&lt;!-- to be accounted for, but they wont be found tied to any particular skill --&gt;
&lt;!-- Find ALL modifiers related to ability-checks --&gt;
[h: abilitySearchArgs = json.set (&quot;&quot;, &quot;object&quot;, toon, 
						&quot;subType&quot;, &quot;ability-checks&quot;)]
[h: abilityMods = dndb_searchGrantedModifiers (abilitySearchArgs)]

&lt;!-- Now tease out the interesting bits --&gt;
&lt;!-- No need to keep searching for stuff. This arry shouldnt be very big --&gt;
[h: abilityValue = 0]
[h, foreach (abilityMod, abilityMods), code: {
	[h: value = json.get (abilityMod, &quot;type&quot;)]
	[h, switch (value):
		case &quot;expertise&quot;: tempAbilityValue = 3;
		case &quot;proficiency&quot;: tempAbilityValue = 2;
		case &quot;half-proficiency&quot;: tempAbilityValue = 1]
	[h: abilityValue = math.max (abilityValue, tempAbilityValue)]
}]

&lt;!-- The most frustrating part about any DTO is trying to sniff out the weird places for user override --&gt;
&lt;!-- values. And its an edge case anyways! So lets fetch all the relevant character values outside of --&gt;
&lt;!-- of the skill loop and just cobble up a dumb map of relevant values --&gt;
[h: characterValues = json.path.read (fatToon, &quot;data.characterValues&quot;)]
[h: characterValuesSearchObj = json.set (&quot;&quot;, &quot;object&quot;, characterValues,
					&quot;valueTypeId&quot;, SKILL_ENTITY_TYPE_ID)]
[h: skillValues = dndb_searchJsonObject (characterValuesSearchObj)]


&lt;!-- Since we cant modify existing skill objects, well build new ones instead. Stuff them into this array --&gt;
[h: afterSkillList = &quot;[]&quot;]

[h: toon = json.set (toon, &quot;data&quot;, skinnyData)]
[h: skillSearchArgs = json.set (&quot;&quot;, &quot;object&quot;, toon,
							&quot;entityTypeId&quot;, SKILL_ENTITY_TYPE_ID)]
[h: skillMods = dndb_searchGrantedModifiers (skillSearchArgs)]


&lt;!-- Too many uncertainties here, so just go through the skill list --&gt;
&lt;!-- Fall back to the generic search instead of more granted modifiers search --&gt;
[h, foreach (skill, skills), code: {
    [h: log.debug (&quot;skill: &quot; + skill)]
	[h: entityId = json.get (skill, &quot;entityId&quot;)]
	[h: name = json.get (skill, &quot;name&quot;)]

	&lt;!-- Start with proficiencies --&gt;
	&lt;!-- Looks for the proficiencies granted by background, class, race, etc --&gt;
	[h: searchArgs = json.set (&quot;&quot;, &quot;object&quot;, skillMods,
							&quot;type&quot;, &quot;expertise&quot;,
							&quot;entityId&quot;, entityId)]
	[h: expertise = dndb_searchJsonObject (searchArgs)]

	[h: searchArgs = json.set (searchArgs, &quot;type&quot;, &quot;proficiency&quot;)]
	[h: proficiencies = dndb_searchJsonObject (searchArgs)]

	[h: searchArgs = json.set (searchArgs, &quot;type&quot;, &quot;half-proficiency&quot;)]
	[h: halfProfs = dndb_searchJsonObject (searchArgs)]

	&lt;!-- go from least to best --&gt;
	[h: proficientValue = 0]
	[h, if (json.length (halfProfs) &gt; 0): proficientValue = 1]
	[h, if (json.length (proficiencies) &gt; 0): proficientValue = 2]
	[h, if (json.length (expertise) &gt; 0): proficientValue = 3]

	[h: actualValue = round (math.max (abilityValue, proficientValue))]
	[h, switch (actualValue):
		case 0: proficientStr = &quot;&quot;;
		case 1: proficientStr = &quot;half&quot;;
		case 2: proficientStr = &quot;proficient&quot;;
		case 3: proficientStr = &quot;expert&quot;
	]
	
	[h: skill = json.set (skill, &quot;proficient&quot;, proficientStr)]

	 &lt;!-- now look for the other ridiculousness --&gt;
	[h: searchArgs = json.set (&quot;&quot;, &quot;object&quot;, skillValues,
					&quot;valueId&quot;, entityId)]
	[h: characterValues = dndb_searchJsonObject (searchArgs)]
	
	[h: bonuses = &quot;[]&quot;]
	&lt;!-- for each choice, inspect the typeId --&gt;
	[h, foreach (characterValue, characterValues), code: {
		&lt;!-- Im at my MapTool nested code limit and I need to go deeper. There are ways around it, but lets try and play by the rules --&gt;
		&lt;!-- Just capture the machine friendly values and transform them out of this loop --&gt;
		[h: typeId = json.get (characterValue, &quot;typeId&quot;)]
		[h, switch (typeId):
			case 23: typeLabel = &quot;Override&quot;;
			case 24: typeLabel = &quot;Misc. Bonus&quot;;
			case 25: typeLabel = &quot;Magic Bonus&quot;;
			case 26: typeLabel = &quot;Proficiency&quot;;
			case 27: typeLabel = &quot;Stat Override&quot;;
			default: typeLabel = typeId;
		]
		[h: value = json.get (characterValue, &quot;value&quot;)]
		[h: bonuses = json.append (bonuses, json.set (&quot;&quot;, 
									&quot;typeId&quot;, typeId,
									&quot;typeLabel&quot;, typeLabel, 
									&quot;value&quot;, value))]
	}]
	[h: skill = json.set (skill, &quot;bonuses&quot;, bonuses)]
	&lt;!-- Weve discovered all the details, but transforming will require another more nesting --&gt;
	&lt;!-- Delegate it. --&gt;

	[h: skill = dndb_transformSkill (toon, skill)]
	[h: afterSkillList = json.append (afterSkillList, skill)]
	
}]

&lt;!-- all done --&gt;
&lt;!-- not quite! Bonus arry needs non-choice bonus also. And give the refactoring one more go --&gt;
&lt;!-- see saves as a new template --&gt;
[h: macro.return = afterSkillList]

</command>
        <label>dndb_getSkill</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Returns an array of all skills or the requested skill, if a name is provided.

arg(0) = toon
optional: arg(1) = skillName

returns
ex.
[
	{
    &quot;name&quot;: &quot;Acrobatics&quot;,
    &quot;ability&quot;: &quot;dex&quot;,
    &quot;valueId&quot;: &quot;3&quot;,
    &quot;bonuses&quot;:     [
            {
        &quot;type&quot;: &quot;Magic&quot;,
        &quot;value&quot;: 0
      },
            {
        &quot;type&quot;: &quot;Misc&quot;,
        &quot;value&quot;: 0
      },
            {
        &quot;type&quot;: &quot;Proficiency&quot;,
        &quot;value&quot;: 0
      },
            {
        &quot;type&quot;: &quot;Ability&quot;,
        &quot;value&quot;: 2
      },
            {
        &quot;type&quot;: &quot;Override&quot;,
        &quot;value&quot;: -1
      }
    ],
    &quot;proficient&quot;: &quot;&quot;,
    &quot;totalBonus&quot;: -1
  }
]</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>35</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>67b3be6b-33b4-4d04-b51e-ac191dddc2ae</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>35</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg (0)]
[h: skill = arg (1)]

&lt;!-- constants --&gt;
[h: OVERRIDE = 23]
[h: MISC_BONUS = 24]
[h: MAGIC_BONUS = 25]
[h: PROF_LEVEL = 26]
[h: ABILITY_OVERRIDE = 27]

[h: NOT_PROFICIENT = &quot;not&quot;]
[h: HALF_PROFICIENT = &quot;half&quot;]
[h: FULL_PROFICIENT = &quot;proficient&quot;]
[h: EXPERT_PROFICIENT = &quot;expert&quot;]

&lt;!-- given a skill, calculate its bonus. The Skill obj weve been given should already --&gt;
&lt;!-- be adorned with the relevant data to calculate, so very little lookup should be required--&gt;
[h: abilities = dndb_getAbilities (toon)]

&lt;!-- start with base skill --&gt;
[h: log.debug (json.indent (skill))]
[h: abilityOverride = json.path.read (skill, &quot;bonuses[*].[?(@.typeId == &quot; + ABILITY_OVERRIDE + &quot;)]&quot;)]
[h: log.debug (&quot;abilityOverride: &quot; + abilityOverride)]
[h, if (json.isEmpty (abilityOverride)), code: {
	[h: skillAbility = json.get (skill, &quot;ability&quot;)]
}; {
	&lt;!-- the value of this bonus corresponds to the ability position --&gt;
	[h: abilityPos = json.path.read (abilityOverride, &quot;[0].value&quot;)]
	[h, switch (abilityPos):
		case 0: skillAbility = &quot;str&quot;;
		case 1: skillAbility = &quot;dex&quot;;
		case 2: skillAbility = &quot;con&quot;;
		case 3: skillAbility = &quot;int&quot;;
		case 4: skillAbility = &quot;wis&quot;;
		case 5: skillAbility = &quot;cha&quot;
	]
}]
[h: log.debug (&quot;skillAbility: &quot; + skillAbility)]
[h: abilityBonusName = skillAbility + &quot;Bonus&quot;]
[h: skillBonus = json.path.read (abilities, abilityBonusName)]
[h: log.debug (&quot;skill bonus: &quot; + skillBonus)]

&lt;!-- Now determine proficiency --&gt;
&lt;!-- If background or class provided proficiency, its set in the skill already --&gt;
[h: proficient = json.get (skill, &quot;proficient&quot;)]
[h: log.debug (&quot;current proficient: &quot; + proficient)]
[h, if (proficient == &quot;&quot;): proficient = NOT_PROFICIENT]


&lt;!-- bonuses may override this --&gt;
[h: profOverride = json.path.read (skill, &quot;bonuses[*].[?(@.typeId == &quot; + PROF_LEVEL + &quot;)]&quot;)]
[h, if (!json.isEmpty (profOverride)), code: {
	[h: profValue = json.path.read (profOverride, &quot;[0].value&quot;)]
	[h, switch (profValue):
		case 1: proficient = NOT_PROFICIENT;
		case 2: proficient = HALF_PROFICIENT;
		case 3: proficient = FULL_PROFICIENT;
		case 4: proficient = EXPERT_PROFICIENT
	]
}]

&lt;!-- determine the actual bonus --&gt;
[h: proficiencyBonus = dndb_getProficiencyBonus (toon)]
[h: log.debug (&quot;proficient after bonus: &quot; + proficient + &quot;; bonus: &quot; + proficiencyBonus)]

&lt;!-- So we made constants for reasons, but maptool hates freedom --&gt;
[h, switch (proficient):
	case &quot;not&quot;: proficiencyBonus = 0;
	case &quot;half&quot;: proficiencyBonus = round (math.floor (proficiencyBonus / 2));
	case &quot;proficient&quot;: proficiencyBonus;
	case &quot;expert&quot;: proficiencyBonus = proficiencyBonus * 2
]
[h: log.debug (&quot;Proficiency: &quot; + proficient + &quot; :: &quot; + proficiencyBonus)]

&lt;!-- Next, sniff out bonus values --&gt;
[h: miscBonusArry = json.path.read (skill, &quot;bonuses[*].[?(@.typeId == &quot; + MISC_BONUS + &quot;)][&apos;value&apos;]&quot;)]
[h, if (!json.isEmpty (miscBonusArry)): miscBonus = json.get (miscBonusArry, 0); miscBonus = 0]
[h: magicBonusArry = json.path.read (skill, &quot;bonuses[*].[?(@.typeId == &quot; + MAGIC_BONUS + &quot;)][&apos;value&apos;]&quot;)]
[h, if (!json.isEmpty (magicBonusArry)): magicBonus = json.get (magicBonusArry, 0); magicBonus = 0]

&lt;!-- and finally, the arbitrary override value --&gt;
[h: overrideBonusArry = json.path.read (skill, &quot;bonuses[*].[?(@.typeId == &quot; + OVERRIDE + &quot;)][&apos;value&apos;]&quot;)]

[h, if (!json.isEmpty (overrideBonusArry)): override = json.get (overrideBonusArry, 0); override = &quot;&quot;]
[h: log.debug (&quot;overrideBonusArry :&quot; + overrideBonusArry + &quot; :: override = &quot; + override)]
&lt;!-- enough lookin, get to doin --&gt;
[h, if (override == &quot;&quot;): totalBonus = skillBonus + proficiencyBonus + miscBonus + magicBonus; totalBonus = override]
&lt;!-- rewrite the bonus arry --&gt;
[h: bonusArry = json.append (&quot;&quot;,
				json.set (&quot;&quot;, &quot;type&quot;, &quot;Magic&quot;, &quot;value&quot;, magicBonus),
				json.set (&quot;&quot;, &quot;type&quot;, &quot;Misc&quot;, &quot;value&quot;, miscBonus),
				json.set (&quot;&quot;, &quot;type&quot;, &quot;Proficiency&quot;, &quot;value&quot;, proficiencyBonus),
				json.set (&quot;&quot;, &quot;type&quot;, &quot;Ability&quot;, &quot;value&quot;, skillBonus),
				json.set (&quot;&quot;, &quot;type&quot;, &quot;Override&quot;, &quot;value&quot;, override))]
[h, if (proficient == &quot;not&quot;): proficient = &quot;&quot;]
[h: skill = json.set (skill, &quot;proficient&quot;, proficient, &quot;bonuses&quot;, bonusArry, &quot;totalBonus&quot;, totalBonus)]
[h: log.debug (json.indent(skill))]
[h: macro.return = skill]

</command>
        <label>dndb_transformSkill</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>arg(0) = toon
arg(1) = skill (the initial generated version by dndb_getSkill)

Callers not dndb_getSkill are unlikely to need this method.</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>36</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>7b02b63c-4635-4c9c-92ef-9ab5256a5fbe</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>36</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- Instead of the usual arg array, try a json obj --&gt;

[h: filterObj = arg(0)]
[h: object = json.get (filterObj, &quot;object&quot;)]
[h: property = json.get (filterObj, &quot;property&quot;)]
[h: even = 1]

[h: filterObj = json.remove (filterObj, &quot;object&quot;)]
[h: filterObj = json.remove (filterObj, &quot;property&quot;)]
&lt;!-- now build the filter --&gt;

[h: rawValues = json.append (&quot;&quot;, &quot;true&quot;, &quot;false&quot;)]

[h: filter = &quot;&quot;]
[h, foreach (field, json.fields (filterObj)), code: {
	&lt;!-- to avoid nesting code, build the filter first, then check if we want it --&gt;
	[h, if (filter == &quot;&quot;): filter = &quot;.[?(&quot;; filter = filter + &quot; &amp;&amp; &quot;]
	[h: rawValue = json.get (filterObj, field)]
	&lt;!-- This is fucking stupid. Ask me why, sometime --&gt;
	[h, if (json.contains (rawValues, rawValue) &gt; 0 || isNumber (rawValue) &gt; 0): 
		filterToken = &quot;@.&quot; + field + &quot; == &quot; + rawValue;
		filterToken = &quot;@.&quot; + field + &quot; == &quot; + &quot;&apos;&quot; + rawValue + &quot;&apos;&quot;]

	[h: filter = filter + filterToken]
}]
[h: filter = filter + &quot;)]&quot;]
&lt;!-- close the filter --&gt;
[h, if (property != &quot;&quot;): filter = filter + &quot;[&apos;&quot; + property + &quot;&apos;]&quot;]
[h: ret = json.path.read (object, filter)]
[h: macro.return = ret]
</command>
        <label>dndb_searchJsonObject</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Performs searches against a JSON object as would json.path.read does. Takes a JSON argument:

arg(0) = 
{
  &quot;object&quot;: &quot;toon&quot;,
  &quot;property&quot;: &quot;fixedValue&quot;,
  &quot;subType&quot;: &quot;ability-checks&quot;,
  &quot;type&quot;: &quot;expertise&quot;
}

Within the JSON, the &quot;object&quot; parameter is required. It can be a full character JSON or a sub-section.

&quot;property&quot; is a reserved parameter that indicates the values to return. If &quot;property&quot; is not provided, the full entity is returned for each match.

All other key-value pairs are used as search terms.

Note: dndb_searchJsonObject must be available to call as an untrusted macro.</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>37</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>804a797d-6805-4436-86a7-9bf29c94a464</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>37</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg(0)]
&lt;!-- todo: some day were gonna get a json package that isnt in english. That --&gt;
&lt;!-- might affect how this (and many other) macros work --&gt;
[h: savesMap = json.append (&quot;&quot;,
			json.set (&quot;&quot;, &quot;name&quot;, &quot;Strength&quot;, &quot;valueId&quot;, &quot;1&quot;, &quot;abilityBonus&quot;, &quot;strBonus&quot;),
			json.set (&quot;&quot;, &quot;name&quot;, &quot;Dexterity&quot;, &quot;valueId&quot;, &quot;2&quot;, &quot;abilityBonus&quot;, &quot;dexBonus&quot;),
			json.set (&quot;&quot;, &quot;name&quot;, &quot;Constitution&quot;, &quot;valueId&quot;, &quot;3&quot;, &quot;abilityBonus&quot;, &quot;conBonus&quot;),
			json.set (&quot;&quot;, &quot;name&quot;, &quot;Intelligence&quot;, &quot;valueId&quot;, &quot;4&quot;, &quot;abilityBonus&quot;, &quot;intBonus&quot;),
			json.set (&quot;&quot;, &quot;name&quot;, &quot;Wisdom&quot;, &quot;valueId&quot;, &quot;5&quot;, &quot;abilityBonus&quot;, &quot;wisBonus&quot;),
			json.set (&quot;&quot;, &quot;name&quot;, &quot;Charisma&quot;, &quot;valueId&quot;, &quot;6&quot;, &quot;abilityBonus&quot;, &quot;chaBonus&quot;)
			)
]
[h, if (json.length (macro.args) &gt; 1): 
	saveNames = json.append (&quot;&quot;, arg(1));
	saveNames = json.append (&quot;&quot;, &quot;Strength&quot;, &quot;Dexterity&quot;, &quot;Constitution&quot;,
					&quot;Intelligence&quot;, &quot;Wisdom&quot;, &quot;Charisma&quot;)
]

&lt;!-- Saving throws are about as stupid as skills, but here we go --&gt;
&lt;!-- Slim down the toon --&gt;
[h: data = json.get (toon, &quot;data&quot;)]
[h: dataRetains = json.append (&quot;&quot;, &quot;modifiers&quot;, &quot;inventory&quot;, &quot;classes&quot;, &quot;stats&quot;, &quot;bonusStats&quot;, &quot;overrideStats&quot;)]
&lt;!-- need these later, but now is a good time to get them --&gt;
[h: abilities = dndb_getAbilities (toon)]
[h: profBonus = dndb_getProficiencyBonus (toon)]

[h: skinnyData = dndb_getSkinnyObject (data, dataRetains)]
&lt;!-- Skinnify the toon --&gt;
[h: fatToon = toon]
[h: skinnyToon = json.set (toon, &quot;data&quot;, skinnyData)]

[h: allProfValue = 1]
[h: searchArgs = json.set (&quot;&quot;, &quot;object&quot;, toon,
							&quot;subType&quot;, &quot;saving-throws&quot;)]
[h: saveMods = dndb_searchGrantedModifiers (searchArgs)]

[h: allProfValue = 0]
[h: allBonus = 0]
[h, foreach (saveMod, saveMods), code: {
	[h: log.debug (&quot;allSaves - saveMod: &quot; + json.indent(saveMod))]
	[h: modLabel = json.get (saveMod, &quot;type&quot;)]
	[h, switch (modLabel):
		case &quot;expertise&quot;: allProfValue = 3;
		case &quot;proficiency&quot;: allProfValue = math.max (allProfValue, 2);
		case &quot;half-proficiency&quot;: allProfValue = math.max (allProfValue, 1);
		case &quot;bonus&quot;: allBonus = allBonus + json.get(saveMod, &quot;value&quot;);
		default: &quot;Someday we&apos;ll care about you, but not today&quot;]
}]
[h: log.debug (&quot;allBonus: &quot; + allBonus)]
[h: finalSaves = &quot;[]&quot;]


[h, foreach (saveName, saveNames), code: {
	[h: valueIdArry = dndb_searchJsonObject (json.set (&quot;&quot;,
						&quot;object&quot;, savesMap,
						&quot;name&quot;, saveName,
						&quot;property&quot;, &quot;valueId&quot;))]
	[h: valueId = json.get (valueIdArry, 0))]
	[h: searchSaveName = lower (saveName + &quot;-saving-throws&quot;)]
	[h: log.debug (&quot;searchSaveName: &quot; + searchSaveName)]

							&quot;type&quot;, &quot;half-proficiency&quot;,
							&quot;property&quot;, &quot;type&quot;
	&lt;!-- first proficiencies --&gt;
	[h: profValue = 1]
	[h: searchArgs = json.set (&quot;&quot;, &quot;object&quot;, skinnyToon,
							&quot;subType&quot;, searchSaveName)]
							
	[h: saveMods = dndb_searchGrantedModifiers (searchArgs)]
	[h: profValue = 0]
	[h: bonus = allBonus]
	[h, foreach (saveMod, saveMods), code: {
		[h: modLabel = json.get (saveMod, &quot;type&quot;)]
		[h, switch (modLabel):
			case &quot;expertise&quot;: profValue = 3;
			case &quot;proficiency&quot;: profValue = math.max (profValue, 2);
			case &quot;half-proficiency&quot;: profValue = math.max (profValue, 1);
			case &quot;bonus&quot;: bonus = bonus + json.get(saveMod, &quot;value&quot;);
			default: &quot;Someday we&apos;ll care about you, but not today&quot;]
	}]


	&lt;!-- character choices; These are not found under data.modifiers, so use the generic searchJsonObject --&gt;
	&lt;!-- override --&gt;
	[h: searchArgs = json.set (&quot;&quot;, &quot;object&quot;, json.path.read (toon, &quot;data.characterValues&quot;),
							&quot;typeId&quot;, &quot;38&quot;,
							&quot;property&quot;, &quot;value&quot;,
							&quot;valueId&quot;, valueId)]
	[h: overrideArry = dndb_searchJsonObject (searchArgs)]

	&lt;!-- Magic Bonus --&gt;
	[h: searchArgs = json.set (searchArgs, &quot;typeId&quot;, &quot;40&quot;)]
	[h: magicArry = dndb_searchJsonObject (searchArgs)]

	&lt;!-- Misc Bonus --&gt;
	[h: searchArgs = json.set (searchArgs, &quot;typeId&quot;, &quot;39&quot;)]
	[h: miscArry = dndb_searchJsonObject (searchArgs)]

	&lt;!-- Proficiency (character choice overrides) --&gt;
	[h: searchArgs = json.set (searchArgs, &quot;typeId&quot;, &quot;41&quot;)]
	[h: profArry = dndb_searchJsonObject (searchArgs)]
	
	[h: choiceProfValue = 0]
	[h, if (json.length(profArry) &gt; 0): choiceProfValue = json.get (profArry, 0)]


	&lt;!-- build the save --&gt;

	[h: bonusArry = &quot;&quot;]
	[h: totalBonus = 0]

	&lt;!-- determine ability bonus --&gt;
	[h: abilitySearchResult = dndb_searchJsonObject (json.set (&quot;&quot;,
									&quot;object&quot;, savesMap,
									&quot;name&quot;, saveName,
									&quot;property&quot;, &quot;abilityBonus&quot;))]

	[h: abilityBonusName = json.get (abilitySearchResult, 0)]
	[h: abilityBonus = json.get (abilities, abilityBonusName)]
	[h: bonusArry = json.append (bonusArry, json.set (&quot;&quot;, &quot;type&quot;, &quot;Ability&quot;, &quot;value&quot;, abilityBonus))]
	[h: totalBonus = totalBonus + abilityBonus]

	&lt;!-- determine proficiency value --&gt;
	[h, if (choiceProfValue &gt; 0): actualProfValue = choiceProfValue;
								actualProfValue = round (math.max (profValue, allProfValue))]

	[h, switch (actualProfValue), code:
		case 0: {
			[h: profBonus = 0]
			[h: proficient = &quot;&quot;]
		};
		case 1: {
			[h: profBonus = round (math.floor (profBonus / 2))]
			[h: proficient = &quot;half&quot;]
		};
		case 2: {
			[h: profBonus = dndb_getProficiencyBonus (toon)]
			[h: proficient = &quot;proficient&quot;]
		};
		case 3: {
			[h: profBonus = profBonus * 2]
			[h: proficient = &quot;expert&quot;]
		}
	]
	[h: totalBonus = totalBonus + profBonus]

	[h: savingThrow = json.set (&quot;&quot;, &quot;name&quot;, saveName,
								&quot;proficient&quot;, proficient,
								&quot;valueId&quot;, valueId)]
	[h: bonusArry = json.append (bonusArry, json.set (&quot;&quot;, &quot;type&quot;, &quot;Proficiency&quot;, &quot;value&quot;, profBonus))]
	
	&lt;!-- class, background, item &quot;bonus&quot; bonuses --&gt;
	[h: totalBonus = totalBonus + bonus]

	&lt;!-- character choices bonuses (magic and misc) --&gt;
	[h: totalMagicBonus = 0]
	[h, foreach (magicBonus, magicArry): totalMagicBonus = totalMagicBonus + magicBonus]
	[h: bonusArry = json.append (bonusArry, json.set (&quot;&quot;, &quot;type&quot;, &quot;Magic&quot;, &quot;value&quot;, totalMagicBonus))]
	[h: totalBonus = totalBonus + totalMagicBonus]

	[h: totalMiscBonus = 0]
	[h, foreach (miscBonus, miscArry): totalMiscBonus = totalMiscBonus + miscBonus]
	[h: bonusArry = json.append (bonusArry, json.set (&quot;&quot;, &quot;type&quot;, &quot;Misc&quot;, &quot;value&quot;, totalMiscBonus))]
	[h: totalBonus = totalBonus + totalMiscBonus]

	&lt;!-- finally, the override --&gt;
	[h: overrideValue = &quot;&quot;]
	[h, if (json.length (overrideArry) &gt; 0), code: {
		&lt;!-- should only be one value --&gt;
		[h: overrideValue = json.get (overrideArry, 0)]
		[h: totalBonus = overrideValue]
	}]
	[h: bonusArry = json.append (bonusArry, json.set (&quot;&quot;, &quot;type&quot;, &quot;Override&quot;, &quot;value&quot;, overrideValue))]
	[h, if (allBonus &gt; 0): bonusArry = json.append (bonusArry, json.set (&quot;&quot;, &quot;type&quot;, &quot;All Bonus&quot;, &quot;value&quot;, allBonus))]

	[h: savingThrow = json.set (savingThrow, &quot;totalBonus&quot;, totalBonus,
									&quot;bonuses&quot;, bonusArry)]
	[h: finalSaves = json.append (finalSaves, savingThrow)]							
}]

[h: macro.return = finalSaves]


</command>
        <label>dndb_getSavingThrow</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>38</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>df00b2ef-138c-47df-b17d-f693ccbd675b</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>38</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- Instead of the usual arg array, try a json obj --&gt;
[h: filterObj = arg(0)]
[h: toon = json.get (filterObj, &quot;object&quot;)]
[h: property = json.get (filterObj, &quot;property&quot;)]
[h: log.debug (&quot;dndb_searchGrantedModifiers: property = &quot; + property)]

[h: resultArry = &quot;&quot;]

&lt;!-- whatevers in equippedModifiers is what we want --&gt;
[h: equippedModifiers = dndb_searchForItemGrantedModifiers (filterObj)]
[h: log.debug (&quot;dndb_searchGrantedModifiers: equippedModifiers = &quot; + equippedModifiers)]
[h: resultArry = json.merge (resultArry, equippedModifiers)]


&lt;!-- Ok, classes are next. Anything that is: --&gt;
[h: classArry = dndb_searchForClassGrantedModifiers (filterObj)]
[h: log.debug (&quot;dndb_searchGrantedModifiers: classArry = &quot; + classArry)]
[h: resultArry = json.merge (resultArry, classArry)]

&lt;!-- filterObj is only filter terms. Well provide our own object and stuff property back in as needed --&gt;

[h: filterObj = json.remove (filterObj, &quot;object&quot;)]
[h: filterObj = json.remove (filterObj, &quot;property&quot;)]

&lt;!-- everything else gets the same treatement --&gt;
&lt;!-- Abstracting Items and Class makese sense since they have special treatement. --&gt;
&lt;!-- Any purpose in doing the same for these? Outside of this script, no sure what --&gt;
&lt;!-- would want to call these scripts anyways --&gt;
[h: nonItems = json.append (&quot;&quot;, &quot;background&quot;, &quot;condition&quot;, &quot;feat&quot;, &quot;race&quot;)]

[h, foreach (classification, nonItems), code: {
	[h: log.debug (&quot;Searching &quot; + classification)]
	[h: searchObjectPath = &quot;data.modifiers.&quot; + classification]
	[h: searchObject = json.path.read (toon, searchObjectPath)]
	[h: subSearchArg = json.set (filterObj, &quot;object&quot;, searchObject, &quot;property&quot;, property)]

	[h: subSearchResults = dndb_searchJsonObject (subSearchArg)]
	[h: log.debug (&quot;dndb_searchGrantedModifiers: subSearchResults = &quot; + subSearchResults)]
	[h, if (json.length (subSearchResults) &gt; 0): resultArry = json.merge (resultArry, subSearchResults)]
}]

[h: log.debug (resultArry)]
[h: macro.return = resultArry]</command>
        <label>dndb_searchGrantedModifiers</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Searches the data.modifier object for all modifiers granted by classes, backgrounds, feats, conditions, race, and equipped items.

arg(0) = 
{
  &quot;object&quot;: &quot;toon&quot;,
  &quot;property&quot;: &quot;fixedValue&quot;,
  &quot;subType&quot;: &quot;ability-checks&quot;,
  &quot;type&quot;: &quot;expertise&quot;
}

Within the JSON, the &quot;object&quot; parameter is required. It must be a full character JSON.

&quot;property&quot; is a reserved parameter that indicates the values to return. If &quot;property&quot; is not provided, the full entity is returned for each match.

All other key-value pairs are used as search terms.</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>39</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>2d2886c7-16e8-4806-851d-9058d425f449</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>39</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- Instead of the usual arg array, try a json obj --&gt;
[h: filterObj = arg(0)]
[h: toon = json.get (filterObj, &quot;object&quot;)]
[h: property = json.get (filterObj, &quot;property&quot;)]

&lt;!-- filterObj is only filter terms. Well provide our own object and stuff property back in as needed --&gt;
[h: filterObj = json.remove (filterObj, &quot;object&quot;)]
[h: filterObj = json.remove (filterObj, &quot;property&quot;)]

[h: resultArry = &quot;&quot;]

&lt;!-- Anything that is: --&gt;
	&lt;!-- granted by a class feature with availableToMultiClass = true --&gt;
	&lt;!-- or granted by a class feature from the starting class --&gt;
	&lt;!-- Each modifier references a componentId. That correlates to data.classes.classFeature.id --&gt;
[h: log.debug (&quot;Searching class&quot;)]
[h: searchObject = json.path.read (toon, &quot;data.modifiers.class&quot;)]
&lt;!-- property-less search. I need the objecct for reference --&gt;
[h: subSearchConfig = json.set (filterObj, &quot;object&quot;, searchObject)]
[h: modifiers = dndb_searchJsonObject (subSearchConfig)]
[h: startingClassDefinition = json.get (json.path.read (toon, &quot;data.classes[*].[?(@.isStartingClass == true)][&apos;definition&apos;]&quot;), 0)]
[h: log.debug (&quot;startingClass: &quot; + json.get(startingClassDefinition, &quot;id&quot;))]
[h, foreach (modifier, modifiers), code: {
	[h: qualified = 0]
	[h: multiClassAllowed = json.get (modifier, &quot;availableToMulticlass&quot;)]
	[h, if (multiClassAllowed == &quot;true&quot;): qualified = 1]
	[h: componentId = json.get (modifier, &quot;componentId&quot;)]
	[h: isGrantedByClass = json.path.read (startingClassDefinition, &quot;classFeatures[*].[?(@.id == &quot; + componentId + &quot;)][&apos;name&apos;]&quot;)]
	[h: log.debug (&quot;isGrantedByClass: &quot; + isGrantedByClass)]
	[h, if (json.length (isGrantedByClass) &gt; 0): qualified = 1]
	&lt;!-- before appending, apply the result property --&gt;
	[h, if (property != &quot;&quot;): modifier = json.get (modifier, property)]
	[h, if (qualified &gt; 0): resultArry = json.append (resultArry, modifier)]
}]

[h: macro.return = resultArry]</command>
        <label>dndb_searchForClassGrantedModifiers</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Searches the data.modifier.classes object for all modifiers granted by classes, restricting those not grantable via multi-classing.

arg(0) = 
{
  &quot;object&quot;: &quot;toon&quot;,
  &quot;property&quot;: &quot;fixedValue&quot;,
  &quot;subType&quot;: &quot;ability-checks&quot;,
  &quot;type&quot;: &quot;expertise&quot;
}

Within the JSON, the &quot;object&quot; parameter is required. It must be a the full character object.

&quot;property&quot; is a reserved parameter that indicates the values to return. If &quot;property&quot; is not provided, the full entity is returned for each match.

All other key-value pairs are used as search terms.</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>40</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>cc778d0b-ed2a-4e00-989b-6dfc4b2d14aa</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>40</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- Instead of the usual arg array, try a json obj --&gt;
[h: filterObj = arg(0)]
[h: toon = json.get (filterObj, &quot;object&quot;)]
[h: property = json.get (filterObj, &quot;property&quot;)]

&lt;!-- filterObj is only filter terms. Well provide our own object and stuff property back in as needed --&gt;
&lt;!-- TODO: I have to pass this object around now, so preserve the original and roll yer own here --&gt;
[h: filterObj = json.remove (filterObj, &quot;object&quot;)]
[h: filterObj = json.remove (filterObj, &quot;property&quot;)]

&lt;!-- Item bonuses are listed in the modifiers object, but should not apply if the associated object isnt --&gt;
&lt;!-- equipped. This first retreives a list of equipped items and builds an arry of ids. Then full modifier --&gt;
&lt;!-- objects are pulled from items and their componentIds checked against equipped ids --&gt;

[h: log.debug (&quot;Searching item&quot;)]
[h: items = json.path.read (toon, &quot;data.inventory&quot;)]
[h: equippedItems = json.path.read (items, &quot;.[?(@.equipped == true)]&quot;)]
[h: equippedItemIds = json.path.read (equippedItems, &quot;[*].definition.id&quot;)]
[h: log.debug (&quot;Equipped items: &quot; + equippedItemIds)]

&lt;!-- now search for modifications from just item and compare componentId with equipped ids --&gt;
[h: itemSearchArg = json.set (filterObj, &quot;object&quot;, json.path.read (toon, &quot;data.modifiers.item&quot;))]
[h: itemSearchResults = dndb_searchJsonObject (itemSearchArg)]
[h: log.debug (&quot;Item search results: &quot; + json.indent (itemSearchResults))]
[h: equippedModifiers = &quot;[]&quot;]
[h, foreach (itemModification, itemSearchResults), code: {
	[h: componentId = json.get (itemModification, &quot;componentId&quot;)]
	[h, if (json.contains (equippedItemIds, componentId) &gt; 0), code: {
		[h: log.debug (&quot;Modification is equipped&quot;)]
		&lt;!-- marshall the result, either scalar or object, into a list --&gt;
		[h, if (property != &quot;&quot;): itemModification = json.path.read (itemModification, property);
								 itemModification = json.append (&quot;&quot;, itemModification)]
		[h: equippedModifiers = json.merge (equippedModifiers, itemModification)]
	}]
}]

[h: macro.return = equippedModifiers]</command>
        <label>dndb_searchForItemGrantedModifiers</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Searches the data.modifier.item object for all modifiers granted by items, restricting those not from unequipped items.

arg(0) = 
{
  &quot;object&quot;: &quot;toon&quot;,
  &quot;property&quot;: &quot;fixedValue&quot;,
  &quot;subType&quot;: &quot;ability-checks&quot;,
  &quot;type&quot;: &quot;expertise&quot;
}

Within the JSON, the &quot;object&quot; parameter is required. It must be a the full character object.

&quot;property&quot; is a reserved parameter that indicates the values to return. If &quot;property&quot; is not provided, the full entity is returned for each match.

All other key-value pairs are used as search terms.</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>41</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>e5690a23-7113-4501-9d06-154e3ef5e045</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>41</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg (0)]

&lt;!-- stuff it into a single json object --&gt;
&lt;!-- The easy bits --&gt;
&lt;!-- need this for init, and I need to come back and do an init DTO --&gt;
[h: abilities = dndb_getAbilities (toon)]
[h: basicToon = json.set (&quot;&quot;, &quot;name&quot;, replace (json.path.read (toon, &quot;data.name&quot;),&quot;null&quot;, &quot;&quot;),
						&quot;age&quot;, replace (json.path.read (toon, &quot;data.age&quot;),&quot;null&quot;, &quot;&quot;),
						&quot;faith&quot;, replace (json.path.read (toon, &quot;data.faith&quot;),&quot;null&quot;, &quot;&quot;),
						&quot;hair&quot;, replace (json.path.read (toon, &quot;data.hair&quot;),&quot;null&quot;, &quot;&quot;),
						&quot;eyes&quot;,  replace (json.path.read (toon, &quot;data.eyes&quot;),&quot;null&quot;, &quot;&quot;),
						&quot;skin&quot;, replace (json.path.read (toon, &quot;data.skin&quot;),&quot;null&quot;, &quot;&quot;),
						&quot;height&quot;, replace (json.path.read (toon, &quot;data.height&quot;),&quot;null&quot;, &quot;&quot;),
						&quot;weight&quot;, replace (json.path.read (toon, &quot;data.weight&quot;),&quot;null&quot;, &quot;&quot;),
						&quot;xp&quot;, replace (json.path.read (toon, &quot;data.currentXp&quot;),&quot;null&quot;, &quot;&quot;),
						&quot;gender&quot;, replace (json.path.read (toon, &quot;data.gender&quot;),&quot;null&quot;, &quot;&quot;),
						&quot;avatarUrl&quot;, replace (json.path.read (toon, &quot;data.avatarUrl&quot;),&quot;null&quot;, &quot;&quot;),
						&quot;url&quot;, replace (json.path.read (toon, &quot;data.readonlyUrl&quot;),&quot;null&quot;, &quot;&quot;),
						&quot;abilities&quot;, abilities)]

&lt;!-- init --&gt;
[h: init = json.get (abilities, &quot;dexBonus&quot;)]
[h: basicToon = json.set (basicToon, &quot;init&quot;, init)]

&lt;!-- alightment map --&gt;
[h: alignmentMap = json.set (&quot;&quot;, &quot;3&quot;, &quot;CE&quot;)]
[h: alignmentId =  json.path.read (toon, &quot;data.alignmentId&quot;)]
[h: basicToon = json.set (basicToon, &quot;alignment&quot;, json.get (alignmentMap, alignmentId))]

&lt;!-- character level --&gt;
[h: totalLevel = 0]
[h: classArry = &quot;&quot;]
[h, foreach (class, json.path.read (toon, &quot;data.classes&quot;)), code: {
	[h: level = json.get (class, &quot;level&quot;)]
	[h: totalLevel = totalLevel + level]
	[h: className = json.path.read (class, &quot;definition.name&quot;)]
	[h: classObj = json.set (&quot;&quot;, &quot;className&quot;, className, &quot;level&quot;, level)]
	[h: hitDice = json.path.read (class, &quot;definition.hitDice&quot;)]
	[h: hitDiceUsed = json.get (class, &quot;hitDiceUsed&quot;)]
	[h: classObj = json.set (classObj, &quot;hitDice&quot;, hitDice, &quot;hitDiceUsed&quot;, hitDiceUsed)]
	[h: classArry = json.append (classArry, classObj)]
}]
[h: log.debug (&quot;classArry: &quot;+ classArry)]
[h: basicToon = json.set (basicToon, &quot;classes&quot;, classArry)]

&lt;!-- HP --&gt;
[h: hitPoints = dndb_getHitPoints (toon)]
[h: basicToon = json.set (basicToon, &quot;hitPoints&quot;, hitPoints)]

&lt;!-- Speed --&gt;
[h: speeds = dndb_getSpeed (toon)]
[h: basicToon = json.set (basicToon, &quot;speeds&quot;, speeds)]

[h: macro.return = basicToon]</command>
        <label>dndb_getBasic</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Returns basic information of the character, including name, race, level, speed, and hit points 

arg (0) = toon</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>42</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>bf008779-b292-4919-90af-aefd899aff14</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>42</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg (0)]

[h: speedsMap = json.append (&quot;&quot;,
			json.set (&quot;&quot;, &quot;name&quot;, &quot;Burrow&quot;, &quot;verb&quot;, &quot;burrowing&quot;),
			json.set (&quot;&quot;, &quot;name&quot;, &quot;Climb&quot;, &quot;verb&quot;, &quot;climbing&quot;),
			json.set (&quot;&quot;, &quot;name&quot;, &quot;Swim&quot;, &quot;verb&quot;, &quot;swimming&quot;),
			json.set (&quot;&quot;, &quot;name&quot;, &quot;Walk&quot;, &quot;verb&quot;, &quot;walking&quot;),
			json.set (&quot;&quot;, &quot;name&quot;, &quot;Fly&quot;, &quot;verb&quot;, &quot;flying&quot;)
			)
]
[h, if (json.length (macro.args) &gt; 1): 
	speedNames = json.append (&quot;&quot;, arg(1));
	speedNames = json.append (&quot;&quot;, &quot;Burrow&quot;, &quot;Climb&quot;, &quot;Swim&quot;, &quot;Walk&quot;, &quot;Fly&quot;)
]

[h: speeds = &quot;[]&quot;]

&lt;!-- Collect base speeds from ractial traits --&gt;
[h: baseSpeeds = json.path.read (toon, &quot;data.race.weightSpeeds.normal&quot;)]

&lt;!-- all speeds bonuses --&gt;
[h: allBonuses = dndb_searchGrantedModifiers (json.set (&quot;&quot;, 
							&quot;object&quot;, toon,
							&quot;property&quot;, &quot;value&quot;,
							&quot;subType&quot;, &quot;speed&quot;,
							&quot;type&quot;, &quot;bonus&quot;))]
							
[h: log.debug (&quot;allBonuses: &quot; + allBonuses)]

[h: allBonus = 0]
[h, foreach (value, allBonuses): allBonus = allBonus + value]

&lt;!-- Foreach speed type, find all the granted bonuses --&gt;
[h, foreach (speedName, speedNames), code: {
	&lt;!-- I may have to revisit this after some testing, but so far Ive only found --&gt;
	&lt;!-- granted bonuses as setting speeds to innate-speed-swimming, for example. --&gt;
	&lt;!-- So look for those for each speed and well add the allBonus values after --&gt;
	[h: verbSpeed = json.get (dndb_searchJsonObject (json.set (&quot;&quot;, &quot;object&quot;, speedsMap, &quot;property&quot;, &quot;verb&quot;, &quot;name&quot;, speedName)), 0)]
	[h: innateSpeed = &quot;innate-speed-&quot; + verbSpeed]
	[h: grantedSpeeds = dndb_searchGrantedModifiers (json.set (&quot;&quot;, 
							&quot;object&quot;, toon,
							&quot;property&quot;, &quot;value&quot;,
							&quot;type&quot;, &quot;set&quot;,
							&quot;subType&quot;, innateSpeed))]
	[h: log.debug (&quot;grantedSpeeds: &quot; + json.indent (grantedSpeeds))]
	[h: setSpeed = 0]
	[h, if (json.length (grantedSpeeds) &gt; 0), code: {
		&lt;!-- get the biggest one --&gt;
		[h: grantedSpeeds = json.sort (grantedSpeeds, &quot;descending&quot;)]
		[h: setSpeed = json.get (grantedSpeeds, 0)]
	}]

	&lt;!-- Find custom speeds and use as overrides --&gt;
	[h: lowerName = lower (speedName)]
	[h: baseSpeed = json.get (baseSpeeds, lowerName)]
	[h: actualSpeed = math.max (baseSpeed, setSpeed)]
	&lt;!-- if actualSpeed is 0, dont apply the allBonus to it --&gt;
	[h, if (actualSpeed &gt; 0): actualSpeed = actualSpeed + allBonus]
	[h: speed = json.set (&quot;&quot;, &quot;name&quot;, speedName,
						&quot;speed&quot;, actualSpeed)]
	&lt;!-- except for walk, dont populate speed 0 --&gt;
	[h, if (lowerName == &quot;walk&quot; || actualSpeed &gt; 0): speeds = json.append (speeds, speed)]
}]

[h: macro.return = speeds]


&lt;!-- Determine encumberance? Its a variant, so skip for now until we determine --&gt;
&lt;!-- a good way of passing that flag --&gt;</command>
        <label>dndb_getSpeed</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Returns the speeds, or requested speed, from the given character

arg(0) = toon
Optional: arg(1) = speed type (ex. &quot;Swimming&quot;)

returns:

[
	{
		&quot;name&quot;:	&quot;Walking&quot;,
		&quot;speed&quot;:	&quot;30&quot;
	},{
		&quot;name&quot;:	&quot;Swimming&quot;,
		&quot;speed&quot;:	&quot;30&quot;
	}
]</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>49</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>5d3adb87-b98f-410d-87d4-15ae627149fa</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>49</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>
[h, if (json.length (macro.args) &gt; 0), code: {
	[h: inputObj = arg (0)]
	[h: bonus = json.get (inputObj, &quot;bonus&quot;)]
	[h: advDisadv = json.get (inputObj, &quot;advDisadv&quot;)]
	[h: checkLabel = json.get (inputObj, &quot;checkLabel&quot;)]
}; {
	&lt;!-- &quot;variableName|value|prompt|inputType|options&quot; --&gt;
	[h: abort (input (
		&quot; checkLabel | A Check | Text &quot;,
		&quot; bonus | 0 | Check bonus | Text &quot;,
		&quot; advDisadv | None, Advantage, Disadvantage | Advantage / Disadvantage | List &quot;))]
}]

[h: checkExpr = &quot;1d20 + &quot; + bonus]
[h: roll1 = eval (checkExpr)]
[h: roll2 = eval (checkExpr)]
[h: actual = roll1]
[h: atkString = &quot;&lt;b&gt;&quot; + checkLabel + &quot;&lt;br&gt;&quot; + checkExpr + &quot;&lt;/b&gt;: &quot; + roll1]
[h, if (advDisadv == 1), code: {
	[h: atkString = atkString + &quot;&lt;br&gt;&lt;b&gt;Advantage:&lt;/b&gt; &quot; + roll2]
	[h: actual = max (roll1, roll2)]
}]
[h, if (advDisadv == 2), code: {
	[h: atkString = atkString + &quot;&lt;br&gt;&lt;b&gt;Disadvantage:&lt;/b&gt; &quot; + roll2]
	[h: actual = min (roll1, roll2)]	
}]
[h, if (advDisadv &gt; 0): atkString = atkString + &quot;&lt;br&gt;&lt;br&gt;&lt;b&gt;Actual:&lt;/b&gt; &quot; + actual]
[r: atkString]</command>
        <label>Make Check</label>
        <group>Token</group>
        <sortby>100</sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>true</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.05em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Generic check macro, usually called as a sub-process but works stand-alone</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>50</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>08fc638a-9d30-479f-9e2d-a1af3960ba2b</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>50</index>
        <colorKey>blue</colorKey>
        <hotKey>None</hotKey>
        <command>[h, if (json.length (macro.args) &gt; 0): inputObj = arg (0); inputObj = &quot;&quot;]
[h: basicToon = getProperty (&quot;dndb_BasicToon&quot;)]
[h, if (encode (basicToon) == &quot;&quot;), code: {
	[h: error = &quot;You must initialize with DNDBeyond first&quot;]
	[h: abort (input ( &quot; junk | | &quot; + error + &quot; | LABEL | TEXT=fals&quot;))]
	[h: return (0, error)]
}]

&lt;!-- if an inputObj was provide, use that instead of the input --&gt;

[h: skills = json.get (basicToon, &quot;skills&quot;)]
[h: skillNameCsv = &quot;&quot;]
[h, foreach (skill, skills), code: {
	[h: skillNameCsv = skillNameCsv + &quot;,&quot; + json.get (skill, &quot;name&quot;)]
}]
[h: skillNameCsv = substring (skillNameCsv, 1)]
[h, if (encode (inputObj) == &quot;&quot;): abort (input ( &quot; selectedSkillPos | &quot; + skillNameCsv + &quot; | Select skill | List &quot;,
					&quot; advDisadv | None, Advantage, Disadvantage | Advantage / Disadvantage | List &quot;,
					&quot; saveAsMacro | 0 | Save as Macro | check &quot;))]
&lt;!-- selection should correspond to the arry position of the skill object --&gt;
[h, if (encode (inputObj) != &quot;&quot;), code: {
	[h: selectedSkillPos = json.get (inputObj, &quot;selectedSkillPos&quot;)]
	[h: advDisadv = json.get (inputObj, &quot;advDisadv&quot;)]
	&lt;!-- never let the passed in object allow to save a macro. else a never ending cycle --&gt;
	[h: saveAsMacro = 0]
}]

[h: skill = json.get (skills, selectedSkillPos)]
[h: skillName = json.get (skill, &quot;name&quot;)]
&lt;!-- if its a &apos;xxxx Ability&apos; then get the xxxx property instead of the skill --&gt;
[h: abilityIndex = indexOf (skillName, &quot; Ability&quot;)]
[h, if (abilityIndex &gt; -1), code: {
	[h: skillName = substring (skillName, 0, abilityIndex)]
	[h: bonus = getProperty (skillName + &quot; Bonus&quot;)]
}; {
	[h: bonus = getProperty (skillName)]
}]

[h: skillCheckObj = json.set (&quot;&quot;, &quot;checkLabel&quot;, json.get (skill, &quot;name&quot;) + &quot; Check&quot;,
							&quot;bonus&quot;, bonus,
							&quot;advDisadv&quot;, advDisadv)]

[h, if (saveAsMacro &gt; 0), code: {
	[h: cmdArg = json.set (&quot;&quot;, &quot;selectedSkillPos&quot;, selectedSkillPos, 
							&quot;advDisadv&quot;, advDisadv)]
	[h, if (advDisadv == 0): advLabel = &quot;&quot;]
	[h, if (advDisadv == 1): advLabel = &quot; (+)&quot;]
	[h, if (advDisadv == 2): advLabel = &quot; (-)&quot;]
	[h: macroName = skillName + advLabel + &quot; Check&quot;]
	[h: currentMacros = getMacros()]
	[h: cmd = &quot;[macro (&apos;Skill Check@Lib:DnDBeyond&apos;): &apos;&quot; + cmdArg + &quot;&apos;]&quot;]
	&lt;!-- dont create duplicates --&gt;
	[h, foreach (currentMacro, currentMacros), if (currentMacro == macroName): saveAsMacro = 0]
	[h: macroConfig = json.set (&quot;&quot;, &quot;applyToSelected&quot;, 1,
								&quot;autoExecute&quot;, 1,
								&quot;color&quot;, &quot;blue&quot;,
								&quot;fontSize&quot;, &quot;1.05em&quot;,
								&quot;sortBy&quot;, selectedSkillPos,
								&quot;fontColor&quot;, &quot;white&quot;,
								&quot;group&quot;, &quot;D&amp;D Beyond - Skills&quot;,
								&quot;playerEditable&quot;, 1)]
	[h, if (saveAsMacro &gt; 0): createMacro (macroName, cmd, macroConfig)]
}]
[r, macro (&quot;Make Check@Lib:DnDBeyond&quot;): skillCheckObj]</command>
        <label>Skill Check</label>
        <group>Token</group>
        <sortby>20</sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>true</applyToTokens>
        <fontColorKey>white</fontColorKey>
        <fontSize>1.05em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>51</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>de3c2d1b-1ada-4781-8081-dcacec15120c</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>51</index>
        <colorKey>black</colorKey>
        <hotKey>None</hotKey>
        <command>[h, if (json.length (macro.args) &gt; 0): inputObj = arg (0); inputObj = &quot;&quot;]
[h: basicToon = getProperty (&quot;dndb_BasicToon&quot;)]
[h, if (encode (basicToon) == &quot;&quot;), code: {
	[h: error = &quot;You must initialize with DNDBeyond first&quot;]
	[h: abort (input ( &quot; junk | | &quot; + error + &quot; | LABEL | TEXT=fals&quot;))]
	[h: return (0, error)]
}]

[h: savingThrows = json.get (basicToon, &quot;savingThrows&quot;)]
[h: savingThrowNameCsv = &quot;&quot;]
[h, foreach (savingThrow, savingThrows), code: {
	[h: savingThrowNameCsv = savingThrowNameCsv + &quot;,&quot; + json.get (savingThrow, &quot;name&quot;)]
}]
[h: savingThrowNameCsv = substring (savingThrowNameCsv, 1)]
[h, if (encode (inputObj) == &quot;&quot;): abort (input ( &quot; selectedsavingThrowPos | &quot; + savingThrowNameCsv + &quot; | Select Saving Throw | List &quot;,
					&quot; advDisadv | None, Advantage, Disadvantage | Advantage / Disadvantage | List &quot;,
					&quot; saveAsMacro | 0 | Save as Macro | check &quot;))]
[h, if (encode (inputObj) != &quot;&quot;), code: {
	[h: selectedsavingThrowPos = json.get (inputObj, &quot;selectedsavingThrowPos&quot;)]
	[h: advDisadv = json.get (inputObj, &quot;advDisadv&quot;)]
	&lt;!-- never let the passed in object allow to save a macro. else a never ending cycle --&gt;
	[h: saveAsMacro = 0]
}]
&lt;!-- selection should correspond to the arry position of the savingThrow object --&gt;
[h: savingThrow = json.get (savingThrows, selectedsavingThrowPos)]
[h: savingThrowName = json.get (savingThrow, &quot;name&quot;) + &quot; Save&quot;]
[h: bonus = getProperty (savingThrowName)]
[h: savingThrowCheckObj = json.set (&quot;&quot;, &quot;checkLabel&quot;, json.get (savingThrow, &quot;name&quot;) + &quot; Saving Throw&quot;,
							&quot;bonus&quot;, bonus,
							&quot;advDisadv&quot;, advDisadv)]

[h, if (saveAsMacro &gt; 0), code: {
	[h: cmdArg = json.set (&quot;&quot;, &quot;selectedsavingThrowPos&quot;, selectedsavingThrowPos, 
							&quot;advDisadv&quot;, advDisadv)]
	[h, if (advDisadv == 0): advLabel = &quot;&quot;]
	[h, if (advDisadv == 1): advLabel = &quot; (+)&quot;]
	[h, if (advDisadv == 2): advLabel = &quot; (-)&quot;]
	[h: macroName = savingThrowName + advLabel]
	[h: currentMacros = getMacros()]
	[h: cmd = &quot;[macro (&apos;Saving Throw@Lib:DnDBeyond&apos;): &apos;&quot; + cmdArg + &quot;&apos;]&quot;]
	&lt;!-- dont create duplicates --&gt;
	[h, foreach (currentMacro, currentMacros), if (currentMacro == macroName): saveAsMacro = 0]
	[h: macroConfig = json.set (&quot;&quot;, &quot;applyToSelected&quot;, 1,
								&quot;autoExecute&quot;, 1,
								&quot;color&quot;, &quot;black&quot;,
								&quot;sortBy&quot;, selectedsavingThrowPos,
								&quot;fontSize&quot;, &quot;1.05em&quot;,
								&quot;fontColor&quot;, &quot;yellow&quot;,
								&quot;group&quot;, &quot;D&amp;D Beyond - Saves&quot;,
								&quot;playerEditable&quot;, 1)]
	[h, if (saveAsMacro &gt; 0): createMacro (macroName, cmd, macroConfig)]
}]


[r, macro (&quot;Make Check@Lib:DnDBeyond&quot;): savingThrowCheckObj]</command>
        <label>Saving Throw</label>
        <group>Token</group>
        <sortby>10</sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>true</applyToTokens>
        <fontColorKey>yellow</fontColorKey>
        <fontSize>1.05em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Yer gonna DIE!</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>53</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>35321cfe-5832-4cfa-a47a-7a70746802e5</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>53</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: macroGroup = &quot;D&amp;D Beyond&quot;]

[h: basicCfg = json.set (&quot;&quot;, &quot;group&quot;, macroGroup,
					&quot;color&quot;, &quot;default&quot;,
					&quot;fontColor&quot;, &quot;default&quot;,
					&quot;autoExecute&quot;, 1,
					&quot;applyToSelected&quot;, 1,
					&quot;playerEditable&quot;, 0,
					&quot;fontSize&quot;, &quot;1.05em&quot;)]

[h: macroCfgs = json.append (&quot;&quot;, 
			json.set (basicCfg, &quot;name&quot;, &quot;Make Check&quot;,
					&quot;sortBy&quot;, &quot;100&quot;,
					&quot;command&quot;, &quot;[macro(&apos;Make Check@Lib:DnDBeyond&apos;): &apos;&apos;]&quot;),
					
			json.set (basicCfg, &quot;name&quot;, &quot;Make Attack&quot;,
					&quot;color&quot;, &quot;red&quot;,
					&quot;fontColor&quot;, &quot;black&quot;,
					&quot;sortBy&quot;, &quot;1&quot;,
					&quot;command&quot;, &quot;[macro(&apos;Make Attack@Lib:DnDBeyond&apos;): &apos;&apos;]&quot;),

			json.set (basicCfg, &quot;name&quot;, &quot;Attack Config&quot;,
					&quot;color&quot;, &quot;green&quot;,
					&quot;fontColor&quot;, &quot;black&quot;,
					&quot;sortBy&quot;, &quot;2&quot;,
					&quot;command&quot;, &quot;[macro(&apos;Attack Config@Lib:DnDBeyond&apos;): &apos;&apos;]&quot;),

			json.set (basicCfg, &quot;name&quot;, &quot;Saving Throw&quot;,
					&quot;color&quot;, &quot;black&quot;,
					&quot;fontColor&quot;, &quot;yellow&quot;,
					&quot;sortBy&quot;, &quot;10&quot;,
					&quot;command&quot;, &quot;[macro(&apos;Saving Throw@Lib:DnDBeyond&apos;): &apos;&apos;]&quot;),

			json.set (basicCfg, &quot;name&quot;, &quot;Spend Hit Dice&quot;,
					&quot;color&quot;, &quot;purple&quot;,
					&quot;fontColor&quot;, &quot;white&quot;,
					&quot;sortBy&quot;, &quot;30&quot;,
					&quot;command&quot;, &quot;[macro(&apos;Spend Hit Dice@Lib:DnDBeyond&apos;): &apos;&apos;]&quot;),
					
			json.set (basicCfg, &quot;name&quot;, &quot;Skill Check&quot;,
					&quot;color&quot;, &quot;blue&quot;,
					&quot;fontColor&quot;, &quot;white&quot;,
					&quot;sortBy&quot;, &quot;20&quot;,
					&quot;command&quot;, &quot;[macro(&apos;Skill Check@Lib:DnDBeyond&apos;): &apos;&apos;]&quot;))]
					
[h, foreach (macroCfg, macroCfgs), code: {
	[h: macroName = json.get (macroCfg, &quot;name&quot;)]
	[h: currentIndexes = getMacroIndexes(macroName)]
	[h, if (currentIndexes == &quot;&quot;), code: {
		[h: createMacro (macroName, json.get (macroCfg, &quot;command&quot;), macroCfg)]
	}]
}]
</command>
        <label>dndb_createPlayerMacros</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>true</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Populates the player token with macros using call-backs to those in the Token group</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>54</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>80fc1873-4419-452c-ab86-d1e5d3e6980c</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>54</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: basicToon = getProperty (&quot;dndb_BasicToon&quot;)]
[h, if (encode(basicToon) == &quot;&quot;), code: {
	[h: errMsg = &quot;Token needs to sync with DnDBeyond first&quot;]
	[h: abort( input(&quot; junk | | &quot; + errMsg + &quot; | LABEL | TEXT=false&quot;))]
	[r: return (0, errMsg)]
}]
[h: toonAttackJson = json.get (basicToon, &quot;attacks&quot;)]
[h: existingAttackJson = getProperty (&quot;attackJSON&quot;)]
&lt;!-- Merge the attack JSON, which means overwrite common key names, add new ones, --&gt;
&lt;!-- but do not clear custom keys --&gt;

&lt;!-- We gotta roll our own merge --&gt;
&lt;!-- Iterate the existing array. If an attack is found the  new array of the same --&gt;
&lt;!-- name, ignore it. Otherwise add the attack to the array. Return the results --&gt;
[h: newAttackJSON = toonAttackJson]

[h, foreach (existingAttack, existingAttackJson), code: {
	[h: newAttack = &quot;&quot;]
	[h: append = 1]
	[h, foreach (toonAttack, toonAttackJson), code: {
		[h: toonAttackName = json.get (toonAttack, &quot;name&quot;)]
		[h: existingAttackJsonName = json.get (existingAttack, &quot;name&quot;)]
		[h, if (toonAttackName == existingAttackJsonName): append = 0]
	}]
	[h, if (append &gt; 0): newAttackJSON = json.append (newAttackJSON, existingAttack)]
}]

[h: setProperty (&quot;attackJSON&quot;, newAttackJSON)]</command>
        <label>dndb_mergeAttackJson</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>true</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Merges the Attack configuration object from DNDBeyond object with the attack configuration stored on the AttackJSON property.</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>55</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>6b19a10a-0b15-4f50-bd7a-9507efe04240</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>55</index>
        <colorKey>red</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- Constants --&gt;
[h: ATTACK_JSON = &quot;attackJSON&quot;]
[h: NAME = &quot;name&quot;]
[h: ATK_BONUS = &quot;atkBonus&quot;]
[h: DMG_BONUS = &quot;dmgBonus&quot;]
[h: DMG_DIE = &quot;dmgDie&quot;]
[h: DMG_DICE = &quot;dmgDice&quot;]
[h: CRIT_BONUS_DICE = &quot;critBonusDice&quot;]
[h: DMG_TYPE = &quot;dmgType&quot;]
[h: DMG_BONUS_EXPR = &quot;dmgBonusExpr&quot;]
[h: NEW_ATTACK = &quot;New Attack&quot;]
[h: LAST_ATTACK_SELECTION = &quot;lastAttackSelection&quot;]
[h: SHOW_DETAILS = &quot;showDetails&quot;]

&lt;!-- Check for a passed in object. Meta-macros will pass this in --&gt;
[h, if (json.length (macro.args) &gt; 0): inputObj = arg (0); inputObj = &quot;&quot;]

&lt;!-- Read attack JSON and prompt for selection --&gt;
[h, if (!isPropertyEmpty (ATTACK_JSON)), code: {
	&lt;!-- Property is populated. Fetch JSON data --&gt;
    [h: attackJson = getProperty(ATTACK_JSON)]
}; {
	&lt;!-- Property is empty, use blank object --&gt;
	[h: attackJson = &quot;&quot;]
}]

[h: arrLen = json.length(attackJson)]
[h, if (arrLen &lt; 1), code: {
	&lt;!-- no attacks found, so create one in the config macro --&gt;
	[h, macro(&quot;Attack Config@global&quot;): &quot;&quot;]
	[h: attackJson = getProperty(ATTACK_JSON)]
}; {
    &lt;!-- no-op --&gt;
}]

&lt;!-- Trying to find the right balance between using Input w/ some contextual information and avoiding
	 the PITA of writing a Form macro --&gt;
[h, if (isPropertyEmpty (SHOW_DETAILS)): showDetails = 0; showDetails = getProperty (SHOW_DETAILS)]

&lt;!-- Build an attack list to pick from. Also, build a detailed label set for the input, if desired --&gt;
[h: attackList = &quot;&quot;]
[h: inputLabelList = &quot;&quot;]
[h, foreach (attack, attackJson), code: {
	[h: attackList = json.append(attackList, json.get(attack, NAME))]
	[h: inputLabelList = inputLabelList + &quot;nothing | nothing | &quot; + json.get(attack, NAME) +
		&quot;: atk=&quot; + json.get(attack,ATK_BONUS) + &quot;, dmg=&quot; + json.get(attack, DMG_DICE) +
		&quot;d&quot; + json.get(attack, DMG_DIE) + &quot; + &quot; + json.get(attack, DMG_BONUS) +
		&quot; + &quot; + json.get(attack, DMG_BONUS_EXPR) + &quot;|LABEL | text=false ##&quot;]
}]
&lt;!-- A little separator --&gt;
[h: inputLabelList = inputLabelList + &quot;nothing | ------------------------------------ | --------------------------------------------------- | label | ##&quot;]
&lt;!-- Locate the index of the last selection to make it the default selection --&gt;
[h: lastSelection = getProperty(LAST_ATTACK_SELECTION)]
[h: selectedIndex = json.indexOf(attackList, lastSelection)]
[h: selectedIndex = if (selectedIndex &lt; 0, 0, selectedIndex)]

&lt;!-- User Input --&gt;
[h, if (encode (inputObj) == &quot;&quot;), code: { 
	[h: abort( input( &quot;selectedAttack | &quot; + json.toList(attackList) + &quot; | Select Attack | list | value=string select=&quot; + selectedIndex,
    		&quot;advantageDisadvantage|None,Advantage,Disadvantage|Advantage/Disadvantage|list|value=string&quot;,
    		&quot;saveAsMacro | 0 | Save as Macro | Check&quot;))]
}]
[h, if (encode (inputObj) != &quot;&quot;), code: {
	[h: selectedAttack = json.get (inputObj, &quot;selectedAttack&quot;)]
	[h: advantageDisadvantage = json.get (inputObj, &quot;advantageDisadvantage&quot;)]
	[h: saveAsMacro = 0]
}]

&lt;!-- Save the selection for next execution as the default selection --&gt;
[h: setProperty(LAST_ATTACK_SELECTION, selectedAttack)]
[h: setProperty(SHOW_DETAILS, showDetails)]

&lt;!-- Attack selected! Fetch the JSON for the selected attack. --&gt;
[h, foreach (attack, attackJson), code: {
	[h: attackName = json.get(attack, NAME)]
	[h, if (attackName == selectedAttack), code: {
		[cfgAttack = attack]
	};{ 0 }]
}]

&lt;!-- transfer json properties to input vars --&gt;
[h: attackBonus = json.get(cfgAttack, ATK_BONUS)]
[h: dmgBonus = json.get(cfgAttack, DMG_BONUS)]
[h: dmgDie = json.get(cfgAttack, DMG_DIE)]
&lt;!-- Some weapons dont do damage and probably shouldnt be here. But dont let that stop the show --&gt;
[h, if (dmgDie == &quot;&quot;): dmgDie = 0]
[h: dmgNumDice = json.get(cfgAttack, DMG_DICE)]
[h, if (dmgNumDice == &quot;&quot;): dmgNumDice = 0]
[h: attackName = json.get(cfgAttack, NAME)]
[h: critBonus = json.get(cfgAttack, CRIT_BONUS_DICE)]
[h: dmgType = json.get(cfgAttack, DMG_TYPE)]
[h: dmgBonusExpr = json.get(cfgAttack, DMG_BONUS_EXPR)]

&lt;!-- Roll attack dice (always roll two, determine if advantage or disadvantage applies after --&gt;
&lt;!-- Unlike dmg rolls that use a full text expression, attack is done in discrete steps to determine criticals --&gt;
[h: attack = 1d20]
[h: attack2 = 1d20]

&lt;!-- Calculate the correct attack roll --&gt;
[h: realAttack = attack]
[h,if (advantageDisadvantage == &quot;Advantage&quot;): realAttack = max(attack, attack2)]
[h,if (advantageDisadvantage == &quot;Disadvantage&quot;): realAttack = min(attack, attack2)]

&lt;!-- Apply critical --&gt;
[h,if (realAttack == 20): dmgNumDice = (dmgNumDice * 2) + critBonus]

&lt;!-- Roll damage --&gt;
[h: dmgExpression = dmgNumDice + &quot;d&quot; + dmgDie + &quot; + &quot; + dmgBonus]
[h: noDmgExpression = json.equals(dmgBonusExpr, &quot;&quot;) + json.equals(dmgBonusExpr, 0)]
[h: dmgExpression = if (noDmgExpression &gt; 0, dmgExpression, dmgExpression + &quot; + &quot; + dmgBonusExpr)]
[h: dmg = eval(dmgExpression)]

&lt;!-- Build the message --&gt;
[h: atkString = &quot;&lt;b&gt;&quot;]
[h: atk2String = &quot;&lt;b&gt;&quot;]
[h,if(attack == 20): atkString = atkString + &quot;&lt;font color=&apos;red&apos;&gt;&lt;i&gt;CRITICAL&lt;/i&gt;&lt;/font&gt; &quot;]
[h,if(attack2 == 20): atk2String = atk2String + &quot;&lt;font color=&apos;red&apos;&gt;&lt;i&gt;CRITICAL&lt;/i&gt;&lt;/font&gt; &quot;]
[h: attack = attack + attackBonus]
[h: attack2 = attack2 + attackBonus]
[h: realAttack = realAttack + attackBonus]
[h,if(advantageDisadvantage != &quot;None&quot;): realAtkString = &quot;&lt;b&gt;&quot; + realAttack + &quot;&lt;/b&gt;&quot;]
[h: atkString = atkString + attack + &quot;&lt;/b&gt;&quot;]
[h: atk2String = atk2String + attack2 + &quot;&lt;/b&gt;&quot;]

[h: nameStr = attackName + &quot;&lt;br&gt;(&quot; + dmgType + &quot;)&lt;br&gt;&lt;br&gt;&quot;]
[h: atkStr = &quot;Attack (1d20 + &quot; + attackBonus + &quot;): &quot; + atkString + &quot;&lt;br&gt;&quot;]
[h,if(advantageDisadvantage != &quot;None&quot;): atkStr = atkStr + advantageDisadvantage + &quot;: &quot; + atk2String + &quot;&lt;br&gt;&lt;br&gt;Actual Attack: &quot; + realAtkString + &quot;&lt;br&gt;&quot;]
[h: dmgStr = &quot;Damage (&quot; + dmgExpression + &quot;): &quot; + dmg]

[r: nameStr]
[r: atkStr]
[r: dmgStr]

&lt;!-- Build the macro --&gt;
[h, if (saveAsMacro &gt; 0), code: {
	[h: cmdArg = json.set (&quot;&quot;, &quot;selectedAttack&quot;, selectedAttack, 
							&quot;advantageDisadvantage&quot;, advantageDisadvantage)]
	[h: advLabel = &quot;&quot;]
	[h, if (advantageDisadvantage == &quot;Advantage&quot;): advLabel = &quot; (+)&quot;]
	[h, if (advantageDisadvantage == &quot;Disadvantage&quot;): advLabel = &quot; (-)&quot;]
	[h: macroName = selectedAttack + advLabel + &quot; Attack&quot;]
	[h: currentMacros = getMacros()]
	[h: cmd = &quot;[macro (&apos;Make Attack@Lib:DnDBeyond&apos;): &apos;&quot; + cmdArg + &quot;&apos;]&quot;]
	&lt;!-- dont create duplicates --&gt;
	[h, foreach (currentMacro, currentMacros), if (currentMacro == macroName): saveAsMacro = 0]
	[h: macroConfig = json.set (&quot;&quot;, &quot;applyToSelected&quot;, 1,
								&quot;autoExecute&quot;, 1,
								&quot;color&quot;, &quot;red&quot;,
								&quot;fontSize&quot;, &quot;1.05em&quot;,
								&quot;fontColor&quot;, &quot;black&quot;,
								&quot;group&quot;, &quot;D&amp;D Beyond - Attacks&quot;,
								&quot;playerEditable&quot;, 1)]
	[h, if (saveAsMacro &gt; 0): createMacro (macroName, cmd, macroConfig)]
}]</command>
        <label>Make Attack</label>
        <group>Token</group>
        <sortby>1</sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>true</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.05em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Do the deed</toolTip>
        <displayHotKey>false</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>56</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>d1536420-1a1e-483c-b779-f8d401d4ccc8</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>56</index>
        <colorKey>green</colorKey>
        <hotKey>None</hotKey>
        <command>
&lt;!-- Constants --&gt;
[h: ATTACK_JSON = &quot;attackJSON&quot;]
[h: NAME = &quot;name&quot;]
[h: ATK_BONUS = &quot;atkBonus&quot;]
[h: DMG_BONUS = &quot;dmgBonus&quot;]
[h: DMG_DIE = &quot;dmgDie&quot;]
[h: DMG_DICE = &quot;dmgDice&quot;]
[h: CRIT_BONUS_DICE = &quot;critBonusDice&quot;]
[h: DMG_TYPE = &quot;dmgType&quot;]
[h: DMG_BONUS_EXPR = &quot;dmgBonusExpr&quot;]
[h: NEW_ATTACK = &quot;New Attack&quot;]

&lt;!-- Read attack JSON and prompt for selection --&gt;
[h, if (!isPropertyEmpty (ATTACK_JSON)), code: {
	&lt;!-- Property is populated. Fetch JSON data --&gt;
    [h: attackJson = getProperty(ATTACK_JSON)]
}; {
	&lt;!-- Property is empty, use blank object --&gt;
	[h: attackJson = &quot;&quot;]
}]

[h: arrLen = json.length(attackJson)]
[h, if (arrLen &lt; 1), code: {
	[h: selectedAttack = NEW_ATTACK]
}; {
    [h: attackList = NEW_ATTACK]  
    [h, foreach (attack, attackJson): attackList = json.append(attackList, json.get(attack, NAME))]
    [h: abort( input( &quot;selectedAttack | &quot; + json.toList(attackList) + &quot; | Select Attack | list | value=string&quot;))]
}]

&lt;!-- Attack selected! Fetch the JSON for the selected attack. If &quot;new&quot; was selected, nothing will be found --&gt;
[h: cfgAttack = json.fromStrProp(NAME + &quot;=&quot; + NEW_ATTACK)]
[h, foreach (attack, attackJson), code: {
	[h: attackName = json.get(attack, NAME)]
	[h, if (attackName == selectedAttack), code: {
		[cfgAttack = attack]
	}; {0}]
}]

&lt;!-- transfer json properties to input vars --&gt;
[h: inputAtkBonus = json.get(cfgAttack, ATK_BONUS)]
[h: inputDmgBonus = json.get(cfgAttack, DMG_BONUS)]
[h: inputDmgDie = json.get(cfgAttack, DMG_DIE)]
[h: inputDmgDice = json.get(cfgAttack, DMG_DICE)]
[h: inputName = json.get(cfgAttack, NAME)]
[h: inputCritBonus = json.get(cfgAttack, CRIT_BONUS_DICE)]
[h: inputDmgType = json.get(cfgAttack, DMG_TYPE)]
[h: inputDmgBonusExpr = json.get(cfgAttack, DMG_BONUS_EXPR)]

&lt;!-- Prompt the input --&gt;
[h: abort( input( &quot;inputName | &quot; + inputName + &quot; | Attack Name | text&quot;,
    &quot;inputAtkBonus | &quot; + inputAtkBonus + &quot; | Attack Bonus | text&quot;,
    &quot;inputDmgBonus | &quot; + inputDmgBonus + &quot; | Damage Bonus | text&quot;,
    &quot;inputDmgDie | &quot; + inputDmgDie + &quot; | Damage Die | text&quot;,
    &quot;inputDmgDice | &quot; + inputDmgDice + &quot; | Number of Damage Dice | text&quot;,
    &quot;inputDmgType | &quot; + inputDmgType + &quot; | Damage Type | text&quot;,
    &quot;inputCritBonus | &quot; + inputCritBonus + &quot; | Extra Critical Dice | text&quot;,
    &quot;inputDmgBonusExpr | &quot; + inputDmgBonusExpr + &quot; | Bonus Damage Expression | text&quot;,
    &quot;inputDeleteAttack | | Delete Attack | check&quot;))]

&lt;!-- Convert the input into a new JSON object --&gt;
[h: cfgAttack = json.set(cfgAttack, 
    NAME, inputName,
    ATK_BONUS, inputAtkBonus,
    DMG_BONUS, inputDmgBonus,
    DMG_DIE, inputDmgDie,
    DMG_DICE, inputDmgDice,
    CRIT_BONUS_DICE, inputCritBonus,
    DMG_TYPE, inputDmgType,
    DMG_BONUS_EXPR, inputDmgBonusExpr)]

[h, if (NEW_ATTACK == selectedAttack), code: {
    &lt;!-- If you added a new attack, just tack it into attackJson --&gt;
    [h: newAttackJson = json.append(attackJson, cfgAttack)]
}; {
    &lt;!-- But if you modifed and existing attack, iterate through the attackJson and replace it --&gt;
    [h: newAttackJson = &quot;&quot;]
    [h, foreach (attack, attackJson), code: {
        [h: attackName = json.get(attack, NAME)]
        [h: attack = if (attackName == selectedAttack, cfgAttack, attack)]
        [h: newAttackJson = if (inputDeleteAttack == 1 &amp;&amp; selectedAttack == json.get(attack, NAME), newAttackJson, json.append(newAttackJson, attack))]
    }]
}]
[h: setProperty(ATTACK_JSON, newAttackJson)]
[r, macro( &quot;Print AttackJSON@global&quot;): &quot;&quot;]

</command>
        <label>Attack Config</label>
        <group>Token</group>
        <sortby>2</sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>true</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.05em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Used to configure attacks. Should be executed at least once before Make Attack.
While this can only configure one attack per execution, bulk configuration is
made possible via Set AttackJSON.</toolTip>
        <displayHotKey>false</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>57</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>b10053d2-ba79-42d6-aa9f-84982aa202e7</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>57</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg (0)]

&lt;!-- HP --&gt;
[h: totalLevel = 0]
[h: classArry = &quot;&quot;]

[h, foreach (class, json.path.read (toon, &quot;data.classes&quot;)), code: {
	[h: level = json.get (class, &quot;level&quot;)]
	[h: totalLevel = totalLevel + level]
	[h: className = json.path.read (class, &quot;definition.name&quot;)]
	[h: classObj = json.set (&quot;&quot;, &quot;className&quot;, className, &quot;level&quot;, level)]
	[h: hitDice = json.path.read (class, &quot;definition.hitDice&quot;)]
	[h: classObj = json.set (classObj, &quot;hitDice&quot;, hitDice)]
	[h: classArry = json.append (classArry, classObj)]
}]

[h: abilities = dndb_getAbilities (toon)]
[h: baseHp =  json.path.read (toon, &quot;data.baseHitPoints&quot;)]
[h: maxHp = baseHp + (json.get (abilities, &quot;conBonus&quot;) * totalLevel)]
[h: damageTaken = json.path.read (toon, &quot;data.removedHitPoints&quot;)]
[h: temporaryHitPoints = json.path.read (toon, &quot;data.temporaryHitPoints&quot;)]
[h: maxHpModifier = json.path.read (toon, &quot;data.bonusHitPoints&quot;)]
[h: overrideMaxHp = json.path.read (toon, &quot;data.overrideHitPoints&quot;)]
[h, if (maxHpModifier != &quot;&quot; &amp;&amp; isNumber (maxHpModifier)): maxHp = maxHp + number (maxHpModifier)]
[h, if (overrideMaxHp != &quot;&quot; &amp;&amp; isNumber (overrideMaxHp)): maxHp = number (overrideMaxHp)]

[h: hitPoints =  json.set (&quot;&quot;,
							&quot;maxHp&quot;, maxHp,
							&quot;currentHp&quot;, maxHp - damageTaken,
							&quot;tempHp&quot;, temporaryHitPoints)]
[h: macro.return = hitPoints]</command>
        <label>dndb_getHitPoints</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>58</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>54049ea9-d360-4107-b703-f7a82040e131</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>58</index>
        <colorKey>purple</colorKey>
        <hotKey>None</hotKey>
        <command>[h: basicToon = getProperty (&quot;dndb_BasicToon&quot;)]
[h, if (encode (basicToon) == &quot;&quot;), code: {
	[h: error = &quot;You must initialize with DNDBeyond first&quot;]
	[h: abort (input ( &quot; junk | | &quot; + error + &quot; | LABEL | TEXT=fals&quot;))]
	[h: return (0, error)]
}]

[h: CLASS_VAR_SUFFIX = &quot;_spendHitDice&quot;]
[h: classes = json.get (basicToon, &quot;classes&quot;)]

&lt;!-- example input string --&gt;
&lt;!-- Barbarian-spendHitDice | 0,1,2,3,4 | Spend Barbarian Hit Dice | List --&gt;
&lt;!-- Fighter-spendHitDice  | 0,1 | Spend Fighter Hit Dice | List --&gt;

&lt;!-- So the challenge here is that are variable name is dynamic. I think I can use the eval --&gt;
&lt;!-- function to help me out here --&gt;

&lt;!-- Build the input string, using ## as a line delimiter --&gt;
[h: inputStr = &quot;&quot;]
[h: classVars = &quot;&quot;]
[h, foreach (class, classes), code: {
	[h: className = json.get (class, &quot;className&quot;)]
	[h: level = json.get (class, &quot;level&quot;)]
	[h: hitDiceUsed = json.get (class, &quot;hitDiceUsed&quot;)]
	[h: hitDice = json.get (class, &quot;hitDice&quot;)]
	[h: totalAvailable = level - hitDiceUsed + 1]
	[h: hitDiceChoices = &quot;&quot;]
	[h, for (i, 0, totalAvailable): hitDiceChoices = hitDiceChoices + &quot;,&quot; + string (i)]
	[h: hitDiceChoices = substring (hitDiceChoices, 1)]
	[h: classVar = className + CLASS_VAR_SUFFIX]
	[h: inputStr = inputStr + &quot;## &quot; + classVar + &quot; | &quot; + hitDiceChoices + 
			&quot; | Spend &quot; + className + &quot; Hit Dice | List | &quot;]
	[h: classVars = json.append (classVars, json.set (&quot;&quot;, &quot;classVar&quot;, classVar, 
												&quot;hitDice&quot;, hitDice,
												&quot;className&quot;, className))]
}]
&lt;!-- prune the leading ## --&gt;
[h: inputStr = substring (inputStr, 3)]
[h: input (inputStr)]
[h: conBonus = getProperty (&quot;Constitution Bonus&quot;)]
[h: total = 0]
[h: output = &quot;&quot;]
[h, foreach (classVar, classVars), code: {
	[h: output = output + &quot;&lt;br&gt;&quot; + json.get (classVar, &quot;className&quot;) + &quot;:&lt;br&gt;&quot;]
	[h: limit = eval (json.get (classVar, &quot;classVar&quot;))]
	[h: dice = json.get (classVar, &quot;hitDice&quot;)]
	[h, for (i, 0, limit), code: {
		[h: expression = &quot;1d&quot; + dice + &quot; + &quot; + conBonus]
		[h: roll = eval (expression)]
		[h: output = output + &quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot; + expression + &quot; = &quot; + roll + &quot;&lt;br&gt;&quot;]
		[h: total = total + roll]
	}]
}]
[r: output]
[r: &quot;&lt;br&gt;Total healed: &quot; + total]</command>
        <label>Spend Hit Dice</label>
        <group>Token</group>
        <sortby>30</sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>true</applyToTokens>
        <fontColorKey>white</fontColorKey>
        <fontSize>1.05em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Note: This doesn&apos;t actually spend the character&apos;s hit dice. It only rolls for the player as if they spent those dice. The player will need to update DNDBeyond and mark the hit dice spent there. Until the next refresh, this macro will always show the same number of hit dice available to spend.</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>59</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>bc443653-0d1d-4b98-bc22-366f2861b57f</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>59</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: object = arg(0)]
[h: retains = arg(1)]

[h: skinnyObj = &quot;{}&quot;]
[h, foreach (field, json.fields (object)), code: {
	[h, if (json.contains (retains, field)): skinnyObj = json.set (skinnyObj, field, json.get (object, field))]
}]
[h: macro.return = skinnyObj]</command>
        <label>dndb_getSkinnyObject</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Returns a object with selected chunks preserved.

arg(0) - object
arg(1) - [fields to preserve]</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
  </macroPropertiesMap>
  <speechMap/>
</net.rptools.maptool.model.Token>
