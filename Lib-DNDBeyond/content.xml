<net.rptools.maptool.model.Token>
  <id>
    <baGUID>Ehs/R/pbT0WG+JmCOQXb0A==</baGUID>
  </id>
  <beingImpersonated>false</beingImpersonated>
  <exposedAreaGUID>
    <baGUID>E/3o5DYCRhy7lz7UIvq8Xg==</baGUID>
  </exposedAreaGUID>
  <imageAssetMap>
    <entry>
      <null/>
      <net.rptools.lib.MD5Key>
        <id>2dba69ffedc32b9fc67a45c4496cba32</id>
      </net.rptools.lib.MD5Key>
    </entry>
  </imageAssetMap>
  <x>4400</x>
  <y>-5400</y>
  <z>7</z>
  <anchorX>0</anchorX>
  <anchorY>0</anchorY>
  <sizeScale>1.0</sizeScale>
  <lastX>4050</lastX>
  <lastY>-5100</lastY>
  <lastPath>
    <cellList class="linked-list">
      <net.rptools.maptool.client.walker.astar.AStarCellPoint>
        <x>81</x>
        <y>-102</y>
        <g>0.0</g>
        <distanceTraveled>0.0</distanceTraveled>
        <distanceTraveledWithoutTerrain>0.0</distanceTraveledWithoutTerrain>
        <h>0.0</h>
        <f>0.0</f>
        <terrainModifier>0.0</terrainModifier>
        <validMoves/>
      </net.rptools.maptool.client.walker.astar.AStarCellPoint>
      <net.rptools.maptool.client.walker.astar.AStarCellPoint>
        <x>82</x>
        <y>-103</y>
        <g>1.0</g>
        <distanceTraveled>1.0</distanceTraveled>
        <distanceTraveledWithoutTerrain>1.0</distanceTraveledWithoutTerrain>
        <parent>
          <x>81</x>
          <y>-102</y>
          <g>0.0</g>
          <distanceTraveled>0.0</distanceTraveled>
          <distanceTraveledWithoutTerrain>0.0</distanceTraveledWithoutTerrain>
          <h>0.0</h>
          <f>0.0</f>
          <terrainModifier>0.0</terrainModifier>
          <validMoves reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint/validMoves"/>
        </parent>
        <h>6.001</h>
        <f>0.0</f>
        <terrainModifier>0.0</terrainModifier>
        <validMoves/>
      </net.rptools.maptool.client.walker.astar.AStarCellPoint>
      <net.rptools.maptool.client.walker.astar.AStarCellPoint>
        <x>83</x>
        <y>-104</y>
        <g>2.0</g>
        <distanceTraveled>2.0</distanceTraveled>
        <distanceTraveledWithoutTerrain>2.0</distanceTraveledWithoutTerrain>
        <parent>
          <x>82</x>
          <y>-103</y>
          <g>1.0</g>
          <distanceTraveled>1.0</distanceTraveled>
          <distanceTraveledWithoutTerrain>1.0</distanceTraveledWithoutTerrain>
          <parent reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint[2]/parent"/>
          <h>6.001</h>
          <f>0.0</f>
          <terrainModifier>0.0</terrainModifier>
          <validMoves reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint[2]/validMoves"/>
        </parent>
        <h>5.002</h>
        <f>0.0</f>
        <terrainModifier>0.0</terrainModifier>
        <validMoves/>
      </net.rptools.maptool.client.walker.astar.AStarCellPoint>
      <net.rptools.maptool.client.walker.astar.AStarCellPoint>
        <x>84</x>
        <y>-105</y>
        <g>3.0</g>
        <distanceTraveled>3.0</distanceTraveled>
        <distanceTraveledWithoutTerrain>3.0</distanceTraveledWithoutTerrain>
        <parent>
          <x>83</x>
          <y>-104</y>
          <g>2.0</g>
          <distanceTraveled>2.0</distanceTraveled>
          <distanceTraveledWithoutTerrain>2.0</distanceTraveledWithoutTerrain>
          <parent reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint[3]/parent"/>
          <h>5.002</h>
          <f>0.0</f>
          <terrainModifier>0.0</terrainModifier>
          <validMoves reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint[3]/validMoves"/>
        </parent>
        <h>4.003</h>
        <f>0.0</f>
        <terrainModifier>0.0</terrainModifier>
        <validMoves/>
      </net.rptools.maptool.client.walker.astar.AStarCellPoint>
      <net.rptools.maptool.client.walker.astar.AStarCellPoint>
        <x>85</x>
        <y>-105</y>
        <g>4.0</g>
        <distanceTraveled>4.0</distanceTraveled>
        <distanceTraveledWithoutTerrain>4.0</distanceTraveledWithoutTerrain>
        <parent>
          <x>84</x>
          <y>-105</y>
          <g>3.0</g>
          <distanceTraveled>3.0</distanceTraveled>
          <distanceTraveledWithoutTerrain>3.0</distanceTraveledWithoutTerrain>
          <parent reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint[4]/parent"/>
          <h>4.003</h>
          <f>0.0</f>
          <terrainModifier>0.0</terrainModifier>
          <validMoves reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint[4]/validMoves"/>
        </parent>
        <h>3.003</h>
        <f>0.0</f>
        <terrainModifier>0.0</terrainModifier>
        <validMoves/>
      </net.rptools.maptool.client.walker.astar.AStarCellPoint>
      <net.rptools.maptool.client.walker.astar.AStarCellPoint>
        <x>86</x>
        <y>-106</y>
        <g>5.0</g>
        <distanceTraveled>5.0</distanceTraveled>
        <distanceTraveledWithoutTerrain>5.0</distanceTraveledWithoutTerrain>
        <parent>
          <x>85</x>
          <y>-105</y>
          <g>4.0</g>
          <distanceTraveled>4.0</distanceTraveled>
          <distanceTraveledWithoutTerrain>4.0</distanceTraveledWithoutTerrain>
          <parent reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint[5]/parent"/>
          <h>3.003</h>
          <f>0.0</f>
          <terrainModifier>0.0</terrainModifier>
          <validMoves reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint[5]/validMoves"/>
        </parent>
        <h>2.002</h>
        <f>0.0</f>
        <terrainModifier>0.0</terrainModifier>
        <validMoves/>
      </net.rptools.maptool.client.walker.astar.AStarCellPoint>
      <net.rptools.maptool.client.walker.astar.AStarCellPoint>
        <x>87</x>
        <y>-107</y>
        <g>6.0</g>
        <distanceTraveled>6.0</distanceTraveled>
        <distanceTraveledWithoutTerrain>6.0</distanceTraveledWithoutTerrain>
        <parent>
          <x>86</x>
          <y>-106</y>
          <g>5.0</g>
          <distanceTraveled>5.0</distanceTraveled>
          <distanceTraveledWithoutTerrain>5.0</distanceTraveledWithoutTerrain>
          <parent reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint[6]/parent"/>
          <h>2.002</h>
          <f>0.0</f>
          <terrainModifier>0.0</terrainModifier>
          <validMoves reference="../../../net.rptools.maptool.client.walker.astar.AStarCellPoint[6]/validMoves"/>
        </parent>
        <h>1.001</h>
        <f>0.0</f>
        <terrainModifier>0.0</terrainModifier>
        <validMoves/>
      </net.rptools.maptool.client.walker.astar.AStarCellPoint>
      <net.rptools.maptool.model.CellPoint>
        <x>88</x>
        <y>-108</y>
        <g>0.0</g>
        <distanceTraveled>7.0</distanceTraveled>
        <distanceTraveledWithoutTerrain>7.0</distanceTraveledWithoutTerrain>
      </net.rptools.maptool.model.CellPoint>
    </cellList>
    <waypointList class="linked-list">
      <net.rptools.maptool.client.walker.astar.AStarCellPoint>
        <x>81</x>
        <y>-102</y>
        <g>0.0</g>
        <distanceTraveled>0.0</distanceTraveled>
        <distanceTraveledWithoutTerrain>0.0</distanceTraveledWithoutTerrain>
        <h>0.0</h>
        <f>0.0</f>
        <terrainModifier>0.0</terrainModifier>
        <validMoves reference="../../../cellList/net.rptools.maptool.client.walker.astar.AStarCellPoint/validMoves"/>
      </net.rptools.maptool.client.walker.astar.AStarCellPoint>
      <net.rptools.maptool.model.CellPoint>
        <x>88</x>
        <y>-108</y>
        <g>0.0</g>
        <distanceTraveled>7.0</distanceTraveled>
        <distanceTraveledWithoutTerrain>7.0</distanceTraveledWithoutTerrain>
      </net.rptools.maptool.model.CellPoint>
    </waypointList>
  </lastPath>
  <snapToScale>true</snapToScale>
  <width>256</width>
  <height>256</height>
  <isoWidth>256</isoWidth>
  <isoHeight>256</isoHeight>
  <scaleX>1.0</scaleX>
  <scaleY>1.0</scaleY>
  <sizeMap>
    <entry>
      <java-class>net.rptools.maptool.model.SquareGrid</java-class>
      <net.rptools.maptool.model.GUID>
        <baGUID>fwABAc9lFSoFAAAAKgABAQ==</baGUID>
      </net.rptools.maptool.model.GUID>
    </entry>
    <entry>
      <java-class>net.rptools.maptool.model.HexGridHorizontal</java-class>
      <net.rptools.maptool.model.GUID>
        <baGUID>fwABAQllXDgBAAAAOAABAQ==</baGUID>
      </net.rptools.maptool.model.GUID>
    </entry>
  </sizeMap>
  <snapToGrid>true</snapToGrid>
  <isVisible>true</isVisible>
  <visibleOnlyToOwner>false</visibleOnlyToOwner>
  <vblColorSensitivity>-1</vblColorSensitivity>
  <alwaysVisibleTolerance>2</alwaysVisibleTolerance>
  <isAlwaysVisible>false</isAlwaysVisible>
  <name>Lib:DnDBeyond</name>
  <ownerType>0</ownerType>
  <tokenShape>SQUARE</tokenShape>
  <tokenType>NPC</tokenType>
  <layer>TOKEN</layer>
  <propertyType>Basic</propertyType>
  <tokenOpacity>1.0</tokenOpacity>
  <terrainModifier>0.0</terrainModifier>
  <terrainModifierOperation>NONE</terrainModifierOperation>
  <terrainModifiersIgnored>
    <net.rptools.maptool.model.Token_-TerrainModifierOperation>NONE</net.rptools.maptool.model.Token_-TerrainModifierOperation>
  </terrainModifiersIgnored>
  <isFlippedX>false</isFlippedX>
  <isFlippedY>false</isFlippedY>
  <sightType>Darkvision</sightType>
  <hasSight>true</hasSight>
  <notes>https://www.dndbeyond.com/profile/Biliruben/characters/9471826</notes>
  <gmNotes></gmNotes>
  <state>
    <entry>
      <string>Other2</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Other3</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Incapacitated</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Dead</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Other4</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Prone</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Hidden</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Disabled</string>
      <boolean>false</boolean>
    </entry>
    <entry>
      <string>Other</string>
      <boolean>false</boolean>
    </entry>
  </state>
  <propertyMapCI>
    <store>
      <entry>
        <string>elevation</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Elevation</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>ac</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>AC</key>
          <value class="string">18</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>constitution</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Constitution</key>
          <value class="string">18</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>israging</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>isRaging</key>
          <value class="string">1</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>initiative</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Initiative</key>
          <value class="string">1</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>strength</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Strength</key>
          <value class="string">18</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>libversion</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>libversion</key>
          <value class="string">0.1</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>hp</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>HP</key>
          <value class="string">125</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>description</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Description</key>
          <value class="string">The best</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>dmgroll</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>dmgRoll</key>
          <value class="string">1d6</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>attackbonus</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>attackBonus</key>
          <value class="string">10</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>ragebonus</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>rageBonus</key>
          <value class="string">3</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>charisma</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Charisma</key>
          <value class="string">8</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>intelligence</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Intelligence</key>
          <value class="string">12</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>wisdom</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Wisdom</key>
          <value class="string">10</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>dexterity</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Dexterity</key>
          <value class="string">13</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>condition</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Condition</key>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>critbonus</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>critBonus</key>
          <value class="string">3</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>defense</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Defense</key>
          <value class="string">Lightening Resistance</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>dmgdie</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>dmgDie</key>
          <value class="string">6</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>dmgbonus</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>dmgBonus</key>
          <value class="string">8</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>movement</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>Movement</key>
          <value class="string">40 Move / 40 Swim</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>oncampaignload</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>onCampaignLoad</key>
          <value class="string">true</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
      <entry>
        <string>dmgnumdice</string>
        <net.rptools.CaseInsensitiveHashMap_-KeyValue>
          <key>dmgNumDice</key>
          <value class="string">1</value>
          <outer-class reference="../../../.."/>
        </net.rptools.CaseInsensitiveHashMap_-KeyValue>
      </entry>
    </store>
  </propertyMapCI>
  <macroPropertiesMap>
    <entry>
      <int>3</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>2705752e-3638-4c9e-be11-b2bc05a840b1</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>3</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>
[h: setProperty (&quot;libversion&quot;, &quot;0.1&quot;)]

&lt;!-- sigh, instead of explicitly defining each one, just inspect the relevant groups and iterate them --&gt;
[h: macros = getMacros()]
[h: log.debug (&quot;macros: &quot; + macros)]
[h, foreach (macroName, macros), code: {
	[h, if (lastIndexOf (macroName, &quot;dndb_&quot;) &gt; -1), code: {
		[h: log.debug (&quot;Registering &quot; + macroName)]
		[h: defineFunction (macroName, macroName + &quot;@this&quot;)]
	}]
}]

&lt;pre&gt;[r: json.indent (getInfo (&quot;client&quot;), 3)]&lt;/pre&gt;</command>
        <label>DNDBeyond Campaign Init</label>
        <group></group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>6</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>d41615d2-6cf5-4400-83a1-33c922e86419</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>6</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- Callers must pass in the character json themselves. No getter methods should shoulder the --&gt;
&lt;!-- responsibility of calling dndb_getCharJSON --&gt;
[h: toon = arg(0)]

&lt;!-- AttackJSON constants --&gt;
[h: ATTACK_JSON = &quot;attackJSON&quot;]
[h: JSON_NAME = &quot;name&quot;]
[h: ATK_BONUS = &quot;atkBonus&quot;]
[h: DMG_BONUS = &quot;dmgBonus&quot;]
[h: DMG_DIE = &quot;dmgDie&quot;]
[h: DMG_DICE = &quot;dmgDice&quot;]

&lt;!-- Crit bonus dice is gonna be dodgey... Use Bode to see if theres a common json path--&gt;
[h: CRIT_BONUS_DICE = &quot;critBonusDice&quot;]
[h: DMG_TYPE = &quot;dmgType&quot;]
[h: DMG_BONUS_EXPR = &quot;dmgBonusExpr&quot;]

[h: attributes = dndb_getAbilities (toon)]
[h: proficiencyBonus = dndb_getProficiencyBonus (toon)]
[h: weapons = dndb_getWeapon (toon)]

&lt;!-- restrict to those that are equipped --&gt;
[h: weapons = json.path.read (weapons, &quot;.[?(@.equipped == &apos;true&apos;)]&quot;)]

[h: weapons = json.append (weapons, dndb_getUnarmedStrike (toon))]
&lt;!-- default to getting equipped weapons. Maybe we&apos;ll add an option later for full list.
&lt;!-- Fuck that, make getWeapons do it
&lt;!-- Defer attack and damage calculations to other macros. They need the work --&gt;

&lt;!-- get Rage feature --&gt;
[h: rageBonus = 0]
[h: ragefeatures = json.path.read (toon, &quot;data.classes..[?(@.definition.name == &apos;Rage&apos;)][&apos;levelScale&apos;]&quot;)]
[h, if (json.length (rageFeatures) &gt; 0): rageBonus = json.get (json.get (rageFeatures, 0), &quot;fixedValue&quot;)]

[h: attackJson = &quot;&quot;]
[h, foreach (weapon, weapons), code: {
	&lt;!-- does not include normal critical dice --&gt;
	[h: critBonusDice = dndb_getCriticalBonusDice (toon, weapon)]
	[h: weaponDmgBonus = dndb_getDamageModifierForWeapon (toon, weapon)]
	[h: weaponAtkBonus = dndb_getAttackModifierForWeapon (toon, weapon)]
	[h: critBonus = dndb_getCriticalBonusDice (toon, weapon)]
	[h: name = json.get (weapon, &quot;name&quot;)]
	[h: attackJsonObj = json.set (&quot;&quot;, JSON_NAME, name,
			ATK_BONUS, weaponAtkBonus,
			DMG_BONUS, weaponDmgBonus,
			DMG_DIE, json.get (weapon, &quot;dmgDie&quot;),
			DMG_DICE, json.get (weapon, &quot;dmgDice&quot;),
			CRIT_BONUS_DICE, critBonus,
			DMG_TYPE, json.get (weapon, &quot;dmgType&quot;))]
	[h: attackJson = json.append (attackJson, attackJsonObj)]
	&lt;!-- Ragable? Make a rage version --&gt;
	[h, if (rageBonus &gt; 0 &amp;&amp; json.get (weapon, &quot;attackType&quot;) == &quot;Melee&quot;), code: {
		[h: attackJsonObj = json.set (attackJsonObj, 
			JSON_NAME, name + &quot; - Raging&quot;,
			DMG_BONUS, weaponDmgBonus + rageBonus)]
		[h: attackJson = json.append (attackJson, attackJsonObj)]
	}]
}]

[h: macro.return = attackJson]</command>
        <label>dndb_getAttackJSON</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>This is a function that requires the DND Beyond Character full JSON. It&apos;s not intended to run stand-alone.

This will pair with a separate class of macros centered around the property &apos;attackJSON&apos;. It will build this property from the class, inventory, and modifier information from the character JSON.</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>10</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>6e67dc4d-7195-453e-aff9-f778ae953674</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>10</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[r, macro (&quot;DNDBeyond Campaign Init@this&quot;): &quot;&quot;]</command>
        <label>onCampaignLoad</label>
        <group></group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>15</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>5cef9493-0ffd-4fcc-909a-b9ca87ac5629</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>15</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- Callers must pass in the character json themselves. No getter methods should shoulder the --&gt;
&lt;!-- responsibility of calling dndb_getCharJSON --&gt;
&lt;!-- Requires two parameters: toon json and weapon object --&gt;
[h: toon = arg(0)]
[h: weapon = arg (1)]

[h: log.debug (&quot;dndb_getAttackModifierForWeapon&quot;)]

&lt;!-- Calculates attack bonus, including that which comes from the toon&apos;s attributes --&gt;
[h: attributes = dndb_getAbilities (toon)]
[h: strBonus = round (math.floor((json.get (attributes, &quot;str&quot;) - 10 ) / 2))]
[h: dexBonus = round (math.floor((json.get (attributes, &quot;dex&quot;) - 10 ) / 2))]
[h: finesseBonus = max (strBonus, dexBonus)]
[h: log.debug (&quot;strBonus: &quot; + strBonus + &quot; - dexBonus: &quot; + dexBonus + &quot; - finesseBonus&quot; + finesseBonus)]

[h, if (json.get (weapon, &quot;attackType&quot;) == &quot;Melee&quot;): abilityBonus = strBonus; abilityBonus = dexBonus]
[h: finesse = json.path.read (weapon, &quot;properties.[?(@.name == &apos;Finesse&apos;)]&quot;)]
[h, if (json.length (finesse) &gt; 0): abilityBonus = finesseBonus]
[h: totalAtkBonus = abilityBonus]
[h: log.debug (&quot;abilityBonus: &quot; + abilityBonus)]

&lt;!-- apply proficiency bonus --&gt;
[h: proficiencyBonus = dndb_getProficiencyBonus (toon)]
[h: proficient = json.get (weapon, &quot;proficient&quot;)]
[h, if (proficient &gt; 0): totalAtkBonus = totalAtkBonus + proficiencyBonus]
[h: log.debug (&quot;proficiencyBonus: &quot; + proficiencyBonus + &quot; - totalAtkBonus: &quot; + totalAtkBonus)]

[h: classAtkModifiers = json.path.read (toon, &quot;data.modifiers.class..[?(@.type == &apos;bonus&apos;)]&quot;)]

&lt;!-- WIP: we only know of some class abilities to parse --&gt;
[h, foreach (classAtkModifier, classAtkModifiers), code : {
	[h: qualified = dndb_isWeaponModifierApplicable (classAtkModifier, weapon)]
	[h: log.debug (json.indent (classAtkModifier, 3))]
	[h: log.debug (&quot;qualified: &quot; + qualified)]
	[h, if (qualified &gt; 0): totalAtkBonus = totalAtkBonus + bonus]
}]

[h: log.debug (&quot;totalAtkBonus after class: &quot; + totalAtkBonus)]
&lt;!-- no Race bonus to apply, yet. need a use case --&gt;


&lt;!-- apply item bonuses only if equipped --&gt;
[h: itemAtkModifiers = json.path.read (toon, &quot;data.modifiers.item..[?(@.type == &apos;bonus&apos;)]&quot;)]
&lt;!-- for ech itemDamageMod, get the componentId. Find the item in inventory with the matching id and check equipped --&gt;
[h, foreach (itemAtkModifier, itemAtkModifiers), code: {
	[h: qualified = dndb_isWeaponModifierApplicable (itemAtkModifier, weapon)]
	[h: log.debug (json.indent (itemAtkModifier, 3))]
	[h: log.debug (&quot;qualified: &quot; + qualified)]
	
	[h: componentId = json.get (itemAtkModifier, &quot;componentId&quot;)]
	[h: items = json.path.read (toon, &quot;data.inventory..[?(@.definition.id == &apos;&quot; + componentId + &quot;&apos;)]&quot;)]
	&lt;!-- should only be one --&gt;
	[h: item = json.get (items, 0)]
	[h: bonus = json.get (itemAtkModifier, &quot;value&quot;)]
	[h: equipped = json.get (item, &quot;equipped&quot;)]
	[h, if (equipped != &quot;true&quot;): qualified = 0]
	[h: log.debug (&quot;Qualified after equipped: &quot; + qualified]
	[h, if (qualified &gt; 0): totalAtkBonus = totalAtkBonus + bonus]
}]

[h: log.debug (&quot;totalAtkBonus after item: &quot; + totalAtkBonus)]

&lt;!-- finally, bonuses on the weapon itself. No check for equipped here. --&gt;
[h: bonus = json.get (weapon, &quot;bonus&quot;)]
[h: totalAtkBonus = totalAtkBonus + bonus]
[h: log.debug (&quot;totalAtkBonus after weapon bonus: &quot; + totalAtkBonus)]

[h: macro.return = totalAtkBonus]</command>
        <label>dndb_getAttackModifierForWeapon</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>16</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>28e908af-387c-45fe-b781-2e2d5431accf</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>16</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- Callers must pass in the character json themselves. No getter methods should shoulder the getCharJSON --&gt;
[h: character = arg(0)]

&lt;!-- Base stats --&gt;
[h: baseStr = json.path.read (character, &quot;data.stats[0].value&quot;)]
[h: baseDex = json.path.read (character, &quot;data.stats[1].value&quot;)]
[h: baseCon = json.path.read (character, &quot;data.stats[2].value&quot;)]
[h: baseInt = json.path.read (character, &quot;data.stats[3].value&quot;)]
[h: baseWis = json.path.read (character, &quot;data.stats[4].value&quot;)]
[h: baseCha = json.path.read (character, &quot;data.stats[5].value&quot;)]

&lt;!-- Bonus stats --&gt;
[h: bonusStr = replace (json.path.read (character, &quot;data.bonusStats[0].value&quot;), &quot;null&quot;, 0)]
[h: bonusDex = replace (json.path.read (character, &quot;data.bonusStats[1].value&quot;), &quot;null&quot;, 0)]
[h: bonusCon = replace (json.path.read (character, &quot;data.bonusStats[2].value&quot;), &quot;null&quot;, 0)]
[h: bonusInt = replace (json.path.read (character, &quot;data.bonusStats[3].value&quot;), &quot;null&quot;, 0)]
[h: bonusWis = replace (json.path.read (character, &quot;data.bonusStats[4].value&quot;), &quot;null&quot;, 0)]
[h: bonusCha = replace (json.path.read (character, &quot;data.bonusStats[5].value&quot;), &quot;null&quot;, 0)]

[h: baseStr = baseStr + bonusStr]
[h: baseDex = baseDex + bonusDex]
[h: baseCon = baseCon + bonusCon]
[h: baseInt = baseInt + bonusInt]
[h: baseWis = baseWis + bonusWis]
[h: baseCha = baseCha + bonusCha]

&lt;!-- Ability improvements --&gt;
[h: strBonuses = json.path.read (character, &quot;.[?(@.subType == &apos;strength-score&apos;)][&apos;fixedValue&apos;]&quot;)]
[h: dexBonuses = json.path.read (character, &quot;.[?(@.subType == &apos;dexterity-score&apos;)][&apos;fixedValue&apos;]&quot;)]
[h: conBonuses = json.path.read (character, &quot;.[?(@.subType == &apos;constitution-score&apos;)][&apos;fixedValue&apos;]&quot;)]
[h: intBonuses = json.path.read (character, &quot;.[?(@.subType == &apos;intelligence-score&apos;)][&apos;fixedValue&apos;]&quot;)]
[h: wisBonuses = json.path.read (character, &quot;.[?(@.subType == &apos;wisdom-score&apos;)][&apos;fixedValue&apos;]&quot;)]
[h: chaBonuses = json.path.read (character, &quot;.[?(@.subType == &apos;charisma-score&apos;)][&apos;fixedValue&apos;]&quot;)]

[h, foreach (strBonus, strBonuses): baseStr = baseStr + strBonus]
[h, foreach (dexBonus, dexBonuses): baseDex = baseDex + dexBonus]
[h, foreach (conBonus, conBonuses): baseCon = baseCon + conBonus]
[h, foreach (intBonus, intBonuses): baseInt = baseInt + intBonus]
[h, foreach (wisBonus, wisBonuses): baseWis = baseWis + wisBonus]
[h, foreach (chaBonus, chaBonuses): baseCha = baseCha + chaBonus]

&lt;!-- Get Override stats and replace base w/ those. Apply only non-zero values --&gt;
[h: overrideStr = json.path.read (character, &quot;data.overrideStats[0].value&quot;)]
[h: overrideDex = json.path.read (character, &quot;data.overrideStats[1].value&quot;)]
[h: overrideCon = json.path.read (character, &quot;data.overrideStats[2].value&quot;)]
[h: overrideInt = json.path.read (character, &quot;data.overrideStats[3].value&quot;)]
[h: overrideWis = json.path.read (character, &quot;data.overrideStats[4].value&quot;)]
[h: overrideCha = json.path.read (character, &quot;data.overrideStats[5].value&quot;)]

[h, if (isNumber (overrideStr)): baseStr = overrideStr]
[h, if (isNumber (overrideDex)): baseDex = overrideDex]
[h, if (isNumber (overrideCon)): baseCon = overrideCon]
[h, if (isNumber (overrideInt)): baseInt = overrideInt]
[h, if (isNumber (overrideWis)): baseWis = overrideWis]
[h, if (isNumber (overrideCha)): baseCha = overrideCha]

[h: attributes = json.set(&quot;&quot;, &quot;str&quot;, baseStr,
							&quot;strBonus&quot;, round (math.floor ((baseStr - 10) / 2)),
							&quot;dex&quot;, baseDex,
							&quot;dexBonus&quot;, round (math.floor ((baseDex - 10) / 2)),
							&quot;con&quot;, baseCon,
							&quot;conBonus&quot;, round (math.floor ((baseCon - 10) / 2)),
							&quot;int&quot;, baseInt,
							&quot;intBonus&quot;, round (math.floor ((baseInt - 10) / 2)),
							&quot;wis&quot;, baseWis,
							&quot;wisBonus&quot;, round (math.floor ((baseWis - 10) / 2)),
							&quot;cha&quot;, baseCha,
							&quot;chaBonus&quot;, round (math.floor ((baseCha - 10) / 2))
							)]
							
[h: log.debug (attributes)]
[h: macro.return = attributes]</command>
        <label>dndb_getAbilities</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>This is a function that requires the DND Beyond Character full JSON. It&apos;s not intended to run stand-alone.</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>17</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>f54d3e38-b1a2-4008-ab42-ca0b899b4c27</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>17</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>
[h: BASE_URL = &quot;https://character-service.dndbeyond.com/character/v3/character/&quot;]
[h: charId = json.get( macro.args, 0 )]


[h: charAt = lastIndexOf (charId, &quot;/&quot;)]


[h, if (charAt &gt; -1): charId = substring (charId, charAt + 1)]

[h: url = BASE_URL + charId]
[h: log.debug (&quot;char url: &quot; + url)]
[h: character = REST.get(url)]
[h: macro.return = character]</command>
        <label>dndb_getCharJSON</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Fetches the JSON package for the provided character number</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>19</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>81459fb9-599c-47e7-9a97-60c38c4ab107</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>19</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg(0)]
[h: weapon = arg(1)]

&lt;!-- only way we know how to do this is by looking for known features --&gt;
[h: bonusCritDice = 0]

&lt;!-- Savage Attacks --&gt;
[h: savageAttackFeatureArry = json.path.read (toon, &quot;data.race..[?(@.definition.name == &apos;Savage Attacks&apos;)]&quot;)]
[h, if (json.length (savageAttackFeatureArry) &gt; 0 &amp;&amp; json.get(weapon, &quot;attackType&quot;) == &quot;Melee&quot;): bonusCritDice = bonusCritDice + 1]

&lt;!-- Brutal Critical --&gt;
&lt;!-- Get the barbarian class --&gt;
[h: barbarianClassLevelArry = json.path.read (toon, &quot;data.classes..[?(@.definition.name == &apos;Barbarian&apos;)][&apos;level&apos;]&quot;)]

[h, if (json.length (barbarianClassLevelArry) &gt; 0): barbarianClassLevel = json.get (barbarianClassLevelArry, 0)]

[h: brutalCrit = 0]
[h: log.debug (&quot;barbarianClassLevel [raw]: &quot; + barbarianClassLevel)]
[h, if (isNumber (barbarianClassLevel)): barbarianClassLevel = number (barbarianClassLevel); barbarianClassLevel = 0]
[h: log.debug (&quot;barbarianClassLevel [number]: &quot; + barbarianClassLevel)]
[h, if (barbarianClassLevel &gt;= 9): brutalCrit = 1]
[h, if (barbarianClassLevel &gt;= 13): brutalCrit = 2]
[h, if (barbarianClassLevel &gt;= 17): brutalCrit = 3]
[h, if (json.get (weapon, &quot;attackType&quot;) == &quot;Melee&quot;): bonusCritDice = bonusCritDice + brutalCrit]


[h: macro.return = bonusCritDice]</command>
        <label>dndb_getCriticalBonusDice</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Returns only the extra dice granted on a critical hit for the given weapon. Does not include the normal critical dice.
arg(0) - Toon
arg(1) - Weapon</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>20</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>123b4eb5-93a8-446e-ab73-a384b15e58c7</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>20</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- Callers must pass in the character json themselves. No getter methods should shoulder the --&gt;
&lt;!-- responsibility of calling dndb_getCharJSON --&gt;
&lt;!-- Requires two parameters: toon json and weapon object --&gt;
[h: toon = arg(0)]
[h: weapon = arg (1)]

[h: bonusType = &quot;damage&quot;]

&lt;!-- Calculates attack bonus, including that which comes from the toon&apos;s attributes --&gt;
[h: attributes = dndb_getAbilities (toon)]
[h: strBonus = round (math.floor((json.get (attributes, &quot;str&quot;) - 10 ) / 2))]
[h: dexBonus = round (math.floor((json.get (attributes, &quot;dex&quot;) - 10 ) / 2))]
[h: finesseBonus = max (strBonus, dexBonus)]

[h, if (json.get (weapon, &quot;attackType&quot;) == &quot;Melee&quot;): abilityBonus = strBonus; abilityBonus = dexBonus]
[h: finesse = json.path.read (weapon, &quot;properties.[?(@.name == &apos;Finesse&apos;)]&quot;)]
[h, if (json.length (finesse) &gt; 0): abilityBonus = finesseBonus]

[h: totalBonus = abilityBonus]

[h: classModifiers = json.path.read (toon, &quot;data.modifiers.class..[?(@.type == &apos;&quot; + bonusType + &quot;&apos;)]&quot;)]

&lt;!-- WIP: we only know of some class abilities to parse --&gt;
[r, foreach (classModifier, classModifiers), code : {
	&lt;!-- Assume qualified and eliminate from there --&gt;

	[h: qualified = 1]
	[h: bonus = json.get (classModifier, &quot;value&quot;)]
	[h: qualified = dndb_isWeaponModifierApplicable (classModifier, weapon)]

	[h, if (qualified &gt; 0): totalBonus = totalBonus + bonus]
}]

&lt;!-- no qualification checks on Race, yet --&gt;
[h: raceDamageModifiers = json.path.read (toon, &quot;data.modifiers.race..[?(@.type == &apos;&quot; + bonusType + &quot;&apos;)]&quot;)]
[h, foreach (raceDamageModifier, raceDamageModifiers), code: {
	[h: bonus = json.get (raceDamageModifier, &quot;value&quot;]
	[h: totalDamageBonus = totalDamageBonus + bonus]
}]

&lt;!-- apply item bonuses only if equipped --&gt;
[h: itemModifiers = json.path.read (toon, &quot;data.modifiers.item..[?(@.type == &apos;&quot; + bonusType + &quot;&apos;)]&quot;)]
&lt;!-- for ech itemDamageMod, get the componentId. Find the item in inventory with the matching id and check equipped --&gt;
[h, foreach (itemModifier, itemModifiers), code: {
	&lt;!-- itemModifier may have attack specific sub-types --&gt;
	[h: qualified = dndb_isWeaponModifierApplicable (itemModifier, weapon)]
	[h: componentId = json.get (itemModifier, &quot;componentId&quot;)]
	[h: items = json.path.read (toon, &quot;data.inventory..[?(@.definition.id == &apos;&quot; + componentId + &quot;&apos;)]&quot;)]
	&lt;!-- should only be one --&gt;
	[h: item = json.get (items, 0)]
	[h: bonus = json.get (itemModifier, &quot;value&quot;)]
	[h: equipped = json.get (item, &quot;equipped&quot;)]
	[h, if (equipped != &quot;true&quot;): qualified = 0]

	[h, if (qualified &gt; 0): totalBonus = totalBonus + bonus]
}]

&lt;!-- finally, bonuses on the weapon itself --&gt;
[h: bonus = json.get (weapon, &quot;bonus&quot;)]
[h: totalBonus = totalBonus + bonus]

[h: macro.return = totalBonus]
</command>
        <label>dndb_getDamageModifierForWeapon</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>21</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>a2c06007-2466-4562-a560-22ed9d96ee58</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>21</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- Callers must pass in the character json themselves. No getter methods should shoulder the --&gt;
&lt;!-- responsibility of calling dndb_getCharJSON --&gt;
[h: character = arg(0)]

[h: classArry = json.path.read (character, &quot;data.classes&quot;)]
&lt;!--Subtract by one for div operation --&gt;
[h: totalClassLevel = -1]
[h, foreach (classDef, classArry), code: {
	[h: totalClassLevel = totalClassLevel + json.get (classDef, &quot;level&quot;)]
}]
[h: profBase = round(math.floor(totalClassLevel / 4))]
&lt;!-- add one, viola --&gt;
[h: proficiency = profBase + 2]
[r: proficiency]
[h: macro.return = proficiency]</command>
        <label>dndb_getProficiencyBonus</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>This is a function that requires the DND Beyond Character full JSON. It&apos;s not intended to run stand-alone. Returns the proficiency bonus based on class level.</toolTip>
        <displayHotKey>false</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>22</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>2579d20f-819b-4c77-baeb-cda99512fbb4</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>22</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg(0)]

&lt;!-- Build it like our simplified weapon json --&gt;
&lt;!-- Do I need the toon? Maybe there are class mods that apply a damage die. --&gt;
[h: unarmedStrike = json.set (&quot;&quot;,
	&quot;name&quot;, &quot;Unarmed Strike&quot;,
	&quot;attackType&quot;, &quot;Melee&quot;,
	&quot;dmgDie&quot;, &quot;1&quot;,
	&quot;dmgDice&quot;, &quot;1&quot;,
	&quot;dmgType&quot;, &quot;Bludgeoning&quot;,
	&quot;bonus&quot;, &quot;0&quot;,
	&quot;range&quot;, &quot;5&quot;,
	&quot;longRange&quot;, &quot;5&quot;,
	&quot;type&quot;, &quot;Unarmed&quot;,
	&quot;properties&quot;, &quot;[]&quot;,
	&quot;proficient&quot;, &quot;1&quot;,
	&quot;isMonk&quot;, &quot;true&quot;)]

[h: macro.return = unarmedStrike]</command>
        <label>dndb_getUnarmedStrike</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>arg(0): toon -although currently unused</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>23</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>5ae8bd14-0e5e-47a8-b4f2-b50ad8b5e55f</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>23</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg(0)]
[h: weaponArry = arg(1)]

[h: basicArry = &quot;[]&quot;]

&lt;!-- Get proficencies --&gt;
[h: proficiencies = json.path.read (toon, &quot;data.modifiers..[?(@.type == &apos;proficiency&apos;)]&quot;)]
&lt;!-- Get proficencies, just the two --&gt;
[h: allProficiencies = json.path.read (toon, &quot;data.modifiers..[?(@.type == &apos;proficiency&apos;)]&quot;)]
[h: weaponProficiencies = json.path.read (allProficiencies,
		&quot;.[?(@.subType in [&apos;simple-weapons&apos;, &apos;martial-weapons&apos;])]&quot;)]

[h, foreach (weaponRaw, weaponArry), code: {
	[h: equipped = json.path.read (weaponRaw, &quot;equipped&quot;)]
	[h: attackType = json.path.read (weaponRaw, &quot;definition.attackType&quot;)]
	[h: grantedModifiers = json.path.read (weaponRaw, &quot;definition.grantedModifiers&quot;)]
	[h: dmgType = json.path.read (weaponRaw, &quot;definition.damageType&quot;)]
	&lt;!-- cant imagine there&apos;s a weapon that grants multiple bonuses, but this is
		an array, so treat it like one even though it&apos;s just one.--&gt;
	[h: bonus = 0]
	[h, foreach (modifier, grantedModifiers), code: {
		[h: bonusType = json.get (modifier, &quot;type&quot;)]
		[h: weaponBonus = json.get (modifier, &quot;value&quot;)]
		[h, if (equals (bonusType, &quot;bonus&quot;) &gt; 0): bonus = bonus + weaponBonus; bonus = bonus]
		[h: dmgType = dmgType + &quot;, &quot; + json.get (modifier, &quot;subType&quot;)]
	}]

	&lt;!-- correlate weapon categoryId w/ weaponProficiency entityId --&gt;
	[h: proficiencyId = json.path.read (weaponRaw, &quot;definition.categoryId&quot;)]
	[h: proficientArry = json.path.read (weaponProficiencies, 
		&quot;.[?(@.entityId == &apos;&quot; + proficiencyId + &quot;&apos;)]&quot;)]
	[h, if (attackType == &quot;1&quot;): attackTypeLabel = &quot;Melee&quot;; attackTypeLabel = &quot;Ranged&quot;]

	[h: basicWeapon = json.set (&quot;&quot;, &quot;name&quot;, json.path.read (weaponRaw, &quot;definition.name&quot;),
		&quot;attackType&quot;, attackTypeLabel,
		&quot;dmgDie&quot;, json.path.read (weaponRaw, &quot;definition.damage.diceValue&quot;),
		&quot;dmgDice&quot;, json.path.read (weaponRaw, &quot;definition.damage.diceCount&quot;),
		&quot;dmgType&quot;, dmgType,
		&quot;bonus&quot;, bonus,
		&quot;range&quot;, json.path.read (weaponRaw, &quot;definition.range&quot;),
		&quot;longRange&quot;, json.path.read (weaponRaw, &quot;definition.longRange&quot;),
		&quot;type&quot;, json.path.read (weaponRaw, &quot;definition.type&quot;),
		&quot;properties&quot;, json.path.read (weaponRaw, &quot;definition.properties&quot;),
		&quot;proficient&quot;, json.length (proficientArry),
		&quot;isMonk&quot;, json.path.read (weaponRaw, &quot;definition.isMonkWeapon&quot;),
		&quot;equipped&quot;, equipped)
	)]

	&lt;!-- bleh, move this to the end so I can save a nested level of execution --&gt;
	[h: basicArry = json.append (basicArry, basicWeapon)]
}]
[h: macro.return = basicArry]</command>
        <label>dndb_convertWeapons</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>This is a function that requires the DND Beyond Character full JSON. It&apos;s not intended to run stand-alone. Returns a simplifed json object of the weapons. Optional boolean flag may be passed to direct if all or only equipped weapons are provided. Default behavior returns only equipped weapons.</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>24</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>39506feb-d52a-41ce-a0ce-8f662b883dd0</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>24</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- Primarily via the subType attribute of the modifier, determine if the weapon applies. --&gt;
&lt;!-- Originally written for weapons, but could be expanded to easily apply to any item --&gt;
[h: modifier = arg(0)]
[h: weapon = arg(1)]
&lt;!-- todo - add a third optional argument to change from an optimistic behavior to a pessimistic --&gt;

[h: qualified = 1]

[h: subType = json.get (modifier, &quot;subType&quot;)]

&lt;!-- if subType is blank, most of our work is pointless --&gt;
[h, if (json.length (subType) == 0): subType = &quot;&quot;]

[h: attackType = json.get (weapon, &quot;attackType&quot;)]

&lt;!-- subType must have &quot;weapon-attack&quot; or weapon-ish attack --&gt;
[h: weaponAttacks = lastIndexOf (subType, &quot;weapon-attack&quot;)]
[h: weaponAttacks = weaponAttacks + lastIndexOf (subType, &quot;melee-attack&quot;)]
[h: weaponAttacks = weaponAttacks + lastIndexOf (subType, &quot;range-attack&quot;)]
[h, if (weaponAttacks &lt; 0): qualified = 0]

&lt;!-- Ranged required? --&gt;
[h: isRangedModifier = lastIndexOf (subType, &quot;range&quot;)]
[h: isMeleeModifier = lastIndexOf (subType, &quot;melee&quot;)]
[h, if (isRangedModifier &gt; -1 &amp;&amp; equals (attackType, &quot;Melee&quot;)): qualified = 0]
[h, if (isMeleeModifier &gt; -1 &amp;&amp; equals (attackType, &quot;Ranged&quot;)): qualified = 0]

&lt;!-- one hand vs two hand restriction --&gt;
[h: twoHandedProperty = json.path.read (weapon, &quot;properties..[?(@.name == &apos;Two-Handed&apos;)]&quot;)]
[h: oneHandedRestriction = lastIndexOf (subType, &quot;one-handed&quot;)]
[h, if (oneHandedRestriction &gt; -1 &amp;&amp; json.length (twoHandedProperty) &gt; 0): qualified = 0]



[h: macro.return = qualified]</command>
        <label>dndb_isWeaponModifierApplicable</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Utility method that tests if a weapon applies to a given modifier. For instance, does the modifier to add 2 points of damage to weapons wielded in one hand apply to the passed in weapon, which may be two-handed.

[h: modifier = arg(0)]
[h: weapon = arg(1)]

Returns 0 (false) or 1 (true)

TODO: this could be refactored to test against any item instead of just weapons.</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>26</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>0c3fa536-271f-4593-8593-540233919c7f</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>26</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg (0)]

&lt;!-- Create a dummy &quot;unarmed&quot; armor just to make the next everything easier --&gt;
[h: unarmored = json.set (&quot;&quot;, &quot;equipped&quot;, &quot;true&quot;,
	&quot;definition&quot;, json.set (&quot;&quot;, &quot;armorClass&quot;, 10,
				&quot;baseArmorName&quot;, &quot;Unarmored&quot;,
				&quot;filterType&quot;, &quot;Armor&quot;,
				&quot;name&quot;, &quot;Unarmored&quot;,
				&quot;stealthCheck&quot;, 1,
				&quot;armorTypeId&quot;, 1))]
&lt;!-- And a dummy &quot;noShield&quot; --&gt;
[h: noShield = json.set (&quot;&quot;, &quot;equipped&quot;, &quot;true&quot;,
	&quot;definition&quot;, json.set (&quot;&quot;, &quot;armorClass&quot;, 0,
				&quot;baseArmorName&quot;, &quot;No Shield&quot;,
				&quot;filterType&quot;, &quot;Shield&quot;,
				&quot;name&quot;, &quot;No Shield&quot;,
				&quot;stealthCheck&quot;, 1,
				&quot;armorTypeId&quot;, 4))]

&lt;!-- Get all armors and shields from inventory --&gt;
[h: allArmors = dndb_getArmor (toon)]
[h: log.debug (&quot;allArmors: &quot; + json.indent (allArmors))]

&lt;!-- Determine equipped armor --&gt;
[h: armors = json.path.read (allArmors, &quot;[*].[?(@.definition.armorTypeId != 4)]&quot;)]
&lt;!-- Select first equipped armor. log.warn if there are more --&gt;
[h: equippedArmors = json.path.read (armors, &quot;[*].[?(@.equipped == true)]&quot;)]
[h: equippedArmorNum = json.length (equippedArmors)]
[h, if (equippedArmorNum &gt; 1): log.warn (&quot;Too many armors equipped, selecting first found armor&quot;)]
[h, if (equippedArmorNum &gt; 0): equippedArmor = json.get(equippedArmors, 0); 
	equippedArmor = unarmored]
&lt;!-- adorn the armor with bonuses --&gt;
[h: equippedArmor = dndb_setArmorBonus (equippedArmor)]
[h: log.debug (&quot;Selecting equipped armor: &quot; + equippedArmor)]

&lt;!-- determine equipped shield --&gt;
[h: shields = json.path.read (allArmors, &quot;[*].[?(@.definition.armorTypeId == 4)]&quot;)]
&lt;!-- Select first equipped shield. log.warn if there are more --&gt;
[h: equippedShields = json.path.read (shields, &quot;[*].[?(@.equipped == true)]&quot;)]
[h: equippedShieldNum = json.length (equippedShields)]
[h, if (equippedShieldNum &gt; 1): log.warn (&quot;Too many shields equipped, selecting first found shield&quot;)]
[h, if (equippedShieldNum &gt; 0): equippedShield = json.get(equippedShields, 0); 
	equippedShield = noShield]
&lt;!-- adorn the shield with bonuses --&gt;
[h: equippedShield = dndb_setArmorBonus (equippedShield)]
[h: log.debug (&quot;Selecting equipped shield: &quot; + equippedShield)]

&lt;!-- Calculate Dexterity bonus --&gt;
[h: attributes = dndb_getAbilities (toon)]
[h: dexBonus = json.get (attributes, &quot;dexBonus&quot;)]

&lt;!-- Apply dex bonus --&gt;
&lt;!-- rules: --&gt;
&lt;!-- no or light armor: full dex bonus --&gt;
&lt;!-- medium armor: dex bonus, up to +2 --&gt;
&lt;!-- heavy armor: No dex bonus (positive or negative) --&gt;
[h: armorTypeId = json.path.read (equippedArmor, &quot;definition.armorTypeId&quot;)]
[h: log.debug (&quot;armorTypeId: &quot; + armorTypeId)]
[h, switch ( armorTypeId ):
	case &quot;1&quot; : dexBonus = dexBonus;
	case &quot;2&quot; : dexBonus = math.min (dexBonus, 2);
	case &quot;3&quot; : dexBonus = 0
]
[h: log.debug (&quot;dexBonus (calculated): &quot; + dexBonus)]

&lt;!-- Look for other modifiers from class abilities --&gt;
&lt;!-- Lets defer this to another script for brevity --&gt;
[h: classACBonus = dndb_getACBonusFromClasses (toon)]
[h: log.debug (&quot;classACBonus: &quot; + json.indent (classACBonus))]

&lt;!-- And build it --&gt;
&lt;!-- Lets recap the players --&gt;
&lt;!-- total: every thing --&gt;
&lt;!-- dexterity: dex bonus, modified --&gt;
&lt;!-- armor: just the equipped armor --&gt;
&lt;!-- shield: just the equipped shield --&gt;
&lt;!-- feature: whatever the feature is providing --&gt;
[h: armorBonus = json.get (equippedArmor, &quot;totalAC&quot;)]
[h: log.debug (&quot;armorBonus: &quot; + armorBonus)]
[h: shieldBonus = json.get (equippedShield, &quot;totalAC&quot;)]
[h: log.debug (&quot;shieldBonus: &quot; + shieldBonus)]
&lt;!-- calculate what we have so far --&gt;
[h: totalACBonus = armorBonus + shieldBonus + dexBonus]
&lt;!-- build the base object --&gt;
[h: acObj = json.set (&quot;&quot;, &quot;Dexterity&quot;, dexBonus,
		&quot;Armor&quot;, armorBonus,
		&quot;Shield&quot;, shieldBonus)]
&lt;!-- and the class features --&gt;
[h: totalClassACBonus = json.get (classACBonus, &quot;totalClassACBonus&quot;)]
[h: totalACBonus = totalACBonus + totalClassACBonus]
[h, foreach (classFeature, json.get (classACBonus, &quot;classFeatures&quot;)), code: {
	[h: classBonus = json.get (classFeature, &quot;dndb_bonus&quot;)]
	[h: featureName = json.path.read (classFeature, &quot;definition.name&quot;)]
	[h: acObj = json.set (acObj, featureName, classBonus)]
}]
&lt;!-- hope this added up correctly --&gt;
[h: acObj = json.set (acObj, &quot;total&quot;, totalACBonus)]
[h: macro.return = acObj]</command>
        <label>dndb_getAC</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Given a character, returns an object with all AC bonuses.

arg(0) : toon

returns acObj
(example)

{
	&quot;total&quot; : 18,
	&quot;Armor&quot; : 10,
	&quot;Dexterity&quot; : 1,
	&quot;Unarmored Bonus&quot; : 4,
	&quot;Shield&quot; : 3
}</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>27</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>3c69b0e1-53ac-4f8f-b364-68912b6556d3</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>27</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: armor = arg(0)]
[h: log.debug (&quot;Getting AC for &quot; + json.path.read (armor, &quot;definition.name&quot;))]
[h: baseAC = json.path.read (armor, &quot;definition.armorClass&quot;)]
[h: log.debug (&quot;baseAC: &quot; + baseAc)]

[h: bonuses = json.path.read (armor, &quot;definition.grantedModifiers.[?(@.subType == &apos;armor-class&apos;)][&apos;value&apos;]&quot;, &quot;SUPPRESS_EXCEPTIONS,ALWAYS_RETURN_LIST&quot;)]
[h: log.debug (&quot;bonuses: &quot; + bonuses)]
[h: totalBonus = 0]
[h, foreach (bonus, bonuses): totalBonus = totalBonus + bonus]
[h: armor = json.set (armor, &quot;bonusAC&quot;, totalBonus, &quot;totalAC&quot;, baseAC + totalBonus)]

[h: macro.return = armor]</command>
        <label>dndb_setArmorBonus</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Utility method to calculate amor class bonuses from the input armor

arg(0) = armor

Return armor with bonus added

Ex. for +3 Shield
{
	&quot;equipped&quot; : true,
	&quot;definition&quot; : [..],
	&quot;bonusAC&quot;: 3
	&quot;totalAC&quot;: 5
}</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>28</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>de054a0e-eaa1-4958-8524-c8c551168f79</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>28</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg(0)]

[h: totalClassACBonus = 0]
[h: classFeatures = &quot;[]&quot;]
&lt;!-- Look for known features --&gt;

&lt;!-- Barbarian --&gt;
[h: barbarian = json.path.read (toon, &quot;data.classes[*].[?(@.definition.name == &apos;Barbarian&apos;)]&quot;)]
[h, if (json.length (barbarian) == 0): barbarian = &quot;{}&quot;]
[h: log.debug (&quot;barbarian: &quot; + json.length (barbarian))]
[h, if (json.length (barbarian) &gt; 0): barbarian = json.get (barbarian, 0)]

&lt;!-- Look for barbarian class feature &quot;Unarmored Defense&quot; --&gt;
[h: level = 0]
[h: unarmoredDefense = &quot;[]&quot;]
[h: level = json.get (barbarian, &quot;level&quot;)]
[h, if (level == &quot;&quot;): level = 0]
[h: log.debug (&quot;level: &quot; + level)]
[h, if (level &gt; 0), code: {
	[h: unarmoredDefense = json.path.read (barbarian,
			&quot;classFeatures[*].[?(@.definition.name == &apos;Unarmored Defense&apos;)]&quot;)]
	[h, if (json.length (unarmoredDefense) &gt; 0): unarmoredDefense = json.get (unarmoredDefense, 0)]
	[h: log.debug (&quot;unarmoredDefense: &quot; + json.indent (unarmoredDefense))]
}; {0}
]

[h, if (json.length (unarmoredDefense) &gt; 0), code: {
	&lt;!-- Confirm the barb isnt wearing armor (note: DND Beyond doesnt check this) --&gt;
	[h: equippedArmors = json.path.read (toon, &quot;data.inventory[*].[?(@.equipped == true &amp;&amp; @.definition.armorTypeId &lt; 4)]&quot;)]
	[h: totalEquipped = json.length (equippedArmors)]
	[h: log.debug (&quot;totalEquipped: &quot; + totalEquipped)]
	[h, if (totalEquipped == 0), code: {
		[h: attributes = dndb_getAbilities (toon)]
		[h: featureBonus = json.get (attributes, &quot;conBonus&quot;)]
		[h: totalClassACBonus = totalClassACBonus + featureBonus]
		&lt;!-- Tack on a bonus attribute: dndb_bonus --&gt;
		[h: unarmoredDefense = json.set (unarmoredDefense, &quot;dndb_bonus&quot;, featureBonus)]
		[h: classFeatures = json.append (classFeatures, unarmoredDefense)]
	}]
}]

&lt;!-- Build the return object --&gt;
[h: acBonuses = json.set (&quot;&quot;, &quot;totalClassACBonus&quot;, totalClassACBonus,
			&quot;classFeatures&quot;, classFeatures)]
[h: macro.return = acBonuses]</command>
        <label>dndb_getACBonusFromClasses</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Returns the AC Bonuses from class features

arg (0) = toon

returns bonusObj

ex.
{
	&quot;totalClassACBonus&quot; : 3,
	&quot;classFeatures&quot; : [ contributing class features ]
}</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>29</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>f55efb56-6729-4eef-971b-e47e7c13b434</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>29</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg (0)]
[h: className = arg (1)]

[h: classObj = json.path.read (toon, &quot;data.classes[*].[?(@.definition.name == &apos;&quot; + className + &quot;&apos;)]&quot;)]

[h: macro.return = classObj]
</command>
        <label>dndb_getClass</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Returns the class object from the toon json.

arg(0) = toon
arg(1) = class name

returns class object found in toon&apos;s:

data.classes[]</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>30</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>bd54c6a8-63f7-4ea5-835f-7f011a7c7df2</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>30</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- get toon and maybe a weapon name --&gt;
[h: toon = arg(0)]
[h, if (json.length (macro.args) &gt; 1):
				weapons = dndb_getInventory (toon, &quot;Weapon&quot;, arg(1)); 
				weapons = dndb_getInventory (toon, &quot;Weapon&quot;)]

[h: weapons = dndb_convertWeapons (toon, weapons)]

[h: macro.return = weapons]</command>
        <label>dndb_getWeapon</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Returns the requested weapon, or all wepons if none specified.

arg(0) = toon
optional: arg (1) = weapon name

Returns weapons in simplified format:
ex.
{
  &quot;name&quot;: &quot;Scimitar of Speed&quot;,
  &quot;attackType&quot;: &quot;Melee&quot;,
  &quot;dmgDie&quot;: 6,
  &quot;dmgDice&quot;: 1,
  &quot;dmgType&quot;: &quot;Slashing, magic&quot;,
  &quot;bonus&quot;: 2,
  &quot;range&quot;: 5,
  &quot;longRange&quot;: 5,
  &quot;type&quot;: &quot;Scimitar&quot;,
  &quot;properties&quot;:   [
        {
      &quot;description&quot;: &quot;When making an attack with a finesse weapon, you use your choice of your Strength or Dexterity modifier for the attack and damage rolls. You must use the same modifier for both rolls. &quot;,
      &quot;id&quot;: 2,
      &quot;name&quot;: &quot;Finesse&quot;
    },
        {
      &quot;description&quot;: &quot;A light weapon is small and easy to handle, making it ideal for use when fighting with two weapons. &quot;,
      &quot;id&quot;: 4,
      &quot;name&quot;: &quot;Light&quot;
    }
  ],
  &quot;proficient&quot;: 2,
  &quot;isMonk&quot;: &quot;false&quot;
}</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>31</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>94bb8df2-cfe3-46ff-a865-cb09ff4196c3</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>31</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- get toon and maybe a armor name --&gt;
[h: toon = arg(0)]
[h, if (json.length (macro.args) &gt; 1): 
				results = dndb_getInventory (toon, &quot;Armor&quot;, arg(1)); 
				results = dndb_getInventory (toon, &quot;Armor&quot;)]
[h: macro.return = results]</command>
        <label>dndb_getArmor</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Returns the requested armor, or all amors if none specified.

arg(0) = toon
optional: arg (1) = armor name

Returns armor without transformation:
ex.
{
    &quot;armorClass&quot;: 11,
    &quot;baseArmorName&quot;: &quot;Leather&quot;,
    &quot;baseItemId&quot;: 10,
    &quot;baseTypeId&quot;: 701257905,
    &quot;bundleSize&quot;: 1,
    &quot;canAttune&quot;: false,
    &quot;canEquip&quot;: true,
    &quot;cost&quot;: 10,
    &quot;description&quot;: &quot;The breastplate and shoulder protectors of this armor are made of leather that has been stiffened by being boiled in oil. The rest of the armor is made of softer and more flexible materials.&quot;,
    &quot;entityTypeId&quot;: 701257905,
    &quot;filterType&quot;: &quot;Armor&quot;,
    &quot;grantedModifiers&quot;: [],
    &quot;id&quot;: 10,
    &quot;isConsumable&quot;: false,
    &quot;isHomebrew&quot;: false,
    &quot;isMonkWeapon&quot;: false,
    &quot;isPack&quot;: false,
    &quot;magic&quot;: false,
    &quot;name&quot;: &quot;Leather&quot;,
    &quot;rarity&quot;: &quot;Common&quot;,
    &quot;stackable&quot;: false,
    &quot;stealthCheck&quot;: 1,
    &quot;tags&quot;: [],
    &quot;type&quot;: &quot;Light Armor&quot;,
    &quot;weaponBehaviors&quot;: [],
    &quot;weight&quot;: 10,
    &quot;sources&quot;: [],
    &quot;armorTypeId&quot;: 1,
    &quot;canBeAddedToInventory&quot;: true
}</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>32</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>e3051e3e-4f96-42d4-8454-1bfa0975a50c</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>32</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- get toon and maybe an item name --&gt;
[h: toon = arg(0)]
[h, if (json.length (macro.args) &gt; 1): 
				results = dndb_getInventory (toon, &quot;Other Gear&quot;, arg(1)); 
				results = dndb_getInventory (toon, &quot;Other Gear&quot;)]
[h: macro.return = results]</command>
        <label>dndb_getItem</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>33</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>6ecf5fe2-3e03-4b4b-89d7-4c569865c73a</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>33</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: log.debug (&quot;Entering getInventory&quot;)]

[h: toon = arg(0)]
[h: filterType = arg(1)]
[h, if (json.length (macro.args) &gt; 2): itemName = arg(2); itemName = &quot;_all&quot;]

[h: log.debug (json.get (toon, &quot;name&quot;))]
[h: log.debug (filterType)]

[h: inventoryArry = json.path.read (toon, &quot;data.inventory[*].[?(@.definition.filterType == &apos;&quot; + filterType + &quot;&apos;)]&quot;)]
[h: selectedItem = json.path.read (inventoryArry, &quot;.[?(@.name == &apos;&quot; + itemName + &quot;&apos;)]&quot;)]
[h, if (json.length (selectedItem) &gt; 0): 
		selectedItem = json.get (selectedItem, 0);
		selectedItem = &quot;{}&quot;]
[h: log.debug (&quot;selectedItem: &quot; + json.indent (selectedItem))]
[h, if (itemName == &quot;_all&quot;): macro.return = inventoryArry; macro.return = selectedItem]</command>
        <label>dndb_getInventory</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Returns an item or items. A filterType must be specified, but a name may be optional.

arg(0) = toon
arg(1) = filterType
optional: arg(2) = name

ex.
dnd_getInventory (toon, &quot;Other Gear&quot;, &quot;Backpack&quot;)

returns:
{
  &quot;baseTypeId&quot;: 2103445194,
  &quot;bundleSize&quot;: 1,
  &quot;canAttune&quot;: false,
  &quot;canEquip&quot;: false,
  &quot;cost&quot;: 2,
  &quot;description&quot;: &quot;A backpack&quot;,
  &quot;entityTypeId&quot;: 2103445194,
  &quot;filterType&quot;: &quot;Other Gear&quot;,
  &quot;grantedModifiers&quot;: [],
  &quot;id&quot;: 20,
  &quot;isConsumable&quot;: false,
  &quot;isHomebrew&quot;: false,
  &quot;isMonkWeapon&quot;: false,
  &quot;isPack&quot;: false,
  &quot;magic&quot;: false,
  &quot;name&quot;: &quot;Backpack&quot;,
  &quot;rarity&quot;: &quot;Common&quot;,
  &quot;stackable&quot;: true,
  &quot;subType&quot;: &quot;Adventuring Gear&quot;,
  &quot;tags&quot;: [&quot;Container&quot;],
  &quot;type&quot;: &quot;Gear&quot;,
  &quot;weaponBehaviors&quot;: [],
  &quot;weight&quot;: 5,
  &quot;sources&quot;: [],
  &quot;gearTypeId&quot;: 1,
  &quot;canBeAddedToInventory&quot;: true
}

</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>34</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>1e117bb6-5e9c-4b9d-beaf-72f275eacf92</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>34</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg(0)]
[h, if (json.length (macro.args) &gt; 1): skillName = arg(1); skillName = &quot;_all&quot;]
&lt;!-- Constants --&gt;
&lt;!-- If we have to revisit skill searching, we may be able to convert the search from --&gt;
&lt;!-- change entityId to valueId to match up with the pattern in saving throw --&gt;
&lt;!-- entityId to typeId == 23 --&gt;
[h: SKILL_ENTITY_TYPE_ID = &quot;1958004211&quot;]

&lt;!-- oddly enough, toon has no base information for skills, only bonuses. So we have --&gt;
&lt;!-- to build it from scratch --&gt;
&lt;!-- oh fuck, the only thing in the toon to point to individual skills are jackass valueIds --&gt;
&lt;!-- So Ima need to map those, also --&gt;
[h: preSkills = json.append (&quot;&quot;,
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Acrobatics&quot;, &quot;ability&quot;, &quot;dex&quot;, &quot;entityId&quot;, &quot;3&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Animal Handling&quot;, &quot;ability&quot;, &quot;wis&quot;, &quot;entityId&quot;, &quot;11&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Arcana&quot;, &quot;ability&quot;, &quot;int&quot;, &quot;entityId&quot;, &quot;6&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Athletics&quot;, &quot;ability&quot;, &quot;str&quot;, &quot;entityId&quot;, &quot;2&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Deception&quot;, &quot;ability&quot;, &quot;cha&quot;, &quot;entityId&quot;, &quot;16&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;History&quot;, &quot;ability&quot;, &quot;int&quot;, &quot;entityId&quot;, &quot;7&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Insight&quot;, &quot;ability&quot;, &quot;wis&quot;, &quot;entityId&quot;, &quot;12&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Intimidation&quot;, &quot;ability&quot;, &quot;cha&quot;, &quot;entityId&quot;, &quot;17&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Investigation&quot;, &quot;ability&quot;, &quot;int&quot;, &quot;entityId&quot;, &quot;8&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Medicine&quot;, &quot;ability&quot;, &quot;wis&quot;, &quot;entityId&quot;, &quot;13&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Nature&quot;, &quot;ability&quot;, &quot;int&quot;, &quot;entityId&quot;, &quot;9&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Perception&quot;, &quot;ability&quot;, &quot;wis&quot;, &quot;entityId&quot;, &quot;14&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Performance&quot;, &quot;ability&quot;, &quot;cha&quot;, &quot;entityId&quot;, &quot;18&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Persuasion&quot;, &quot;ability&quot;, &quot;cha&quot;, &quot;entityId&quot;, &quot;19&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Religion&quot;, &quot;ability&quot;, &quot;int&quot;, &quot;entityId&quot;, &quot;10&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Sleight of Hand&quot;, &quot;ability&quot;, &quot;dex&quot;, &quot;entityId&quot;, &quot;4&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Stealth&quot;, &quot;ability&quot;, &quot;dex&quot;, &quot;entityId&quot;, &quot;5&quot;),
		json.set (&quot;&quot;, &quot;name&quot;, &quot;Survival&quot;, &quot;ability&quot;, &quot;wis&quot;, &quot;entityId&quot;, &quot;15&quot;)
)]

[h: skills = &quot;[]&quot;]
[h, foreach (skill, preSkills), code: {
	[h, if (skillName == &quot;_all&quot; || skillName == json.get (skill, &quot;name&quot;)): skills = json.append (skills, skill)] 
}]

&lt;!-- Lets call this the Rex Redrum bug: features that grant all ability checks some level of proficiency have --&gt;
&lt;!-- to be accounted for, but they wont be found tied to any particular skill --&gt;
[h: abilitySearchArgs = json.set (&quot;&quot;, &quot;object&quot;, toon, 
						&quot;subType&quot;, &quot;ability-checks&quot;,
						&quot;type&quot;, &quot;expertise&quot;)]
&lt;!-- what fucking DM allowed this? --&gt;
[h: abilityExpertise = dndb_searchJsonObject (abilitySearchArgs)]

[h: abilitySearchArgs = json.set (abilitySearchArgs, &quot;type&quot;, &quot;proficiency&quot;)]
[h: abilityProficiency = dndb_searchJsonObject (abilitySearchArgs)]

[h: abilitySearchArgs = json.set (abilitySearchArgs, &quot;type&quot;, &quot;half-proficiency&quot;)]
[h: abilityHalfProficiency = dndb_searchJsonObject (abilitySearchArgs)]

[h: abilityValue = 0]
[h, if (json.length (abilityHalfProficiency) &gt; 0): abilityValue = 1]
[h, if (json.length (abilityProficiency) &gt; 0): abilityValue = 2]
[h, if (json.length (abilityExpertise) &gt; 0): abilityValue = 3]

&lt;!-- Since we cant modify existing skill objects, well build new ones instead. Stuff them into this array --&gt;
[h: afterSkillList = &quot;[]&quot;]

[h, foreach (skill, skills), code: {
    [h: log.debug (&quot;skill: &quot; + skill)]
	[h: entityId = json.get (skill, &quot;entityId&quot;)]
	[h: name = json.get (skill, &quot;name&quot;)]

	&lt;!-- Start with proficiencies --&gt;
	&lt;!-- Looks for the proficiencies granted by background, class, race, etc --&gt;
	[h: searchArgs = json.set (&quot;&quot;, &quot;object&quot;, json.path.read(toon, &quot;data.modifiers&quot;),
							&quot;entityTypeId&quot;, SKILL_ENTITY_TYPE_ID,
							&quot;type&quot;, &quot;expertise&quot;,
							&quot;entityId&quot;, entityId)]
	[h: expertise = dndb_searchJsonObject (searchArgs)]
	[h: log.debug (&quot;Expertise: &quot; + json.indent (expertise))]

	[h: searchArgs = json.set (searchArgs, &quot;type&quot;, &quot;proficiency&quot;)]
	[h: proficiencies = dndb_searchJsonObject (searchArgs)]
	[h: log.debug (&quot;Proficiencies: &quot; + json.indent (proficiencies))]

	[h: searchArgs = json.set (searchArgs, &quot;type&quot;, &quot;half-proficiency&quot;)]
	[h: halfProfs = dndb_searchJsonObject (searchArgs)]
	[h: log.debug (&quot;Half Profs: &quot; + json.indent (halfProfs))]

	&lt;!-- go from least to best --&gt;
	[h: proficientValue = 0]
	[h, if (json.length (halfProfs) &gt; 0): proficientValue = 1]
	[h, if (json.length (proficiencies) &gt; 0): proficientValue = 2]
	[h, if (json.length (expertise) &gt; 0): proficientValue = 3]

	[h: actualValue = round (math.max (abilityValue, proficientValue))]
	[h, switch (actualValue):
		case 0: proficientStr = &quot;&quot;;
		case 1: proficientStr = &quot;half&quot;;
		case 2: proficientStr = &quot;proficient&quot;;
		case 3: proficientStr = &quot;expert&quot;
	]
	
	[h: skill = json.set (skill, &quot;proficient&quot;, proficientStr)]

	 &lt;!-- now look for the other ridiculousness --&gt;
	[h: searchArgs = json.set (&quot;&quot;, &quot;object&quot;, toon,
					&quot;valueTypeId&quot;, SKILL_ENTITY_TYPE_ID, 
					&quot;valueId&quot;, entityId)]
	[h: characterValues = dndb_searchJsonObject (searchArgs)]
	[h: log.debug (&quot;characterValues: &quot; + characterValues)]
	
	[h: bonuses = &quot;[]&quot;]
	&lt;!-- for each choice, inspect the typeId --&gt;
	[h, foreach (characterValue, characterValues), code: {
		&lt;!-- Im at my MapTool nested code limit and I need to go deeper. There are ways around it, but lets try and play by the rules --&gt;
		&lt;!-- Just capture the machine friendly values and transform them out of this loop --&gt;
		[h: typeId = json.get (characterValue, &quot;typeId&quot;)]
		[h, switch (typeId):
			case 23: typeLabel = &quot;Override&quot;;
			case 24: typeLabel = &quot;Misc. Bonus&quot;;
			case 25: typeLabel = &quot;Magic Bonus&quot;;
			case 26: typeLabel = &quot;Proficiency&quot;;
			case 27: typeLabel = &quot;Stat Override&quot;;
			default: typeLabel = typeId;
		]
		[h: value = json.get (characterValue, &quot;value&quot;)]
		[h: bonuses = json.append (bonuses, json.set (&quot;&quot;, 
									&quot;typeId&quot;, typeId,
									&quot;typeLabel&quot;, typeLabel, 
									&quot;value&quot;, value))]
	}]
	[h: skill = json.set (skill, &quot;bonuses&quot;, bonuses)]
	&lt;!-- Weve discovered all the details, but transforming will require another more nesting --&gt;
	&lt;!-- Delegate it. --&gt;

	[h: skill = dndb_transformSkill (toon, skill)]
	[h: afterSkillList = json.append (afterSkillList, skill)]
	
}]

&lt;!-- all done --&gt;
&lt;!-- not quite! Bonus arry needs non-choice bonus also. And give the refactoring one more go --&gt;
&lt;!-- see saves as a new template --&gt;
[h: macro.return = afterSkillList]
</command>
        <label>dndb_getSkill</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Returns an array of all skills or the requested skill, if a name is provided.

arg(0) = toon
optional: arg(1) = skillName

returns
ex.
[
	{
    &quot;name&quot;: &quot;Acrobatics&quot;,
    &quot;ability&quot;: &quot;dex&quot;,
    &quot;valueId&quot;: &quot;3&quot;,
    &quot;bonuses&quot;:     [
            {
        &quot;type&quot;: &quot;Magic&quot;,
        &quot;value&quot;: 0
      },
            {
        &quot;type&quot;: &quot;Misc&quot;,
        &quot;value&quot;: 0
      },
            {
        &quot;type&quot;: &quot;Proficiency&quot;,
        &quot;value&quot;: 0
      },
            {
        &quot;type&quot;: &quot;Ability&quot;,
        &quot;value&quot;: 2
      },
            {
        &quot;type&quot;: &quot;Override&quot;,
        &quot;value&quot;: -1
      }
    ],
    &quot;proficient&quot;: &quot;&quot;,
    &quot;totalBonus&quot;: -1
  }
]</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>35</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>4131bde6-5cb1-4148-a1bf-e4f875638fc1</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>35</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg (0)]
[h: skill = arg (1)]

&lt;!-- constants --&gt;
[h: OVERRIDE = 23]
[h: MISC_BONUS = 24]
[h: MAGIC_BONUS = 25]
[h: PROF_LEVEL = 26]
[h: ABILITY_OVERRIDE = 27]

[h: NOT_PROFICIENT = &quot;not&quot;]
[h: HALF_PROFICIENT = &quot;half&quot;]
[h: FULL_PROFICIENT = &quot;proficient&quot;]
[h: EXPERT_PROFICIENT = &quot;expert&quot;]

&lt;!-- given a skill, calculate its bonus. The Skill obj weve been given should already --&gt;
&lt;!-- be adorned with the relevant data to calculate, so very little lookup should be required--&gt;
[h: abilities = dndb_getAbilities (toon)]

&lt;!-- start with base skill --&gt;
[h: log.debug (json.indent (skill))]
[h: abilityOverride = json.path.read (skill, &quot;bonuses[*].[?(@.typeId == &quot; + ABILITY_OVERRIDE + &quot;)]&quot;)]
[h: log.debug (&quot;abilityOverride: &quot; + abilityOverride)]
[h, if (json.isEmpty (abilityOverride)), code: {
	[h: skillAbility = json.get (skill, &quot;ability&quot;)]
}; {
	&lt;!-- the value of this bonus corresponds to the ability position --&gt;
	[h: abilityPos = json.path.read (abilityOverride, &quot;[0].value&quot;)]
	[h, switch (abilityPos):
		case 0: skillAbility = &quot;str&quot;;
		case 1: skillAbility = &quot;dex&quot;;
		case 2: skillAbility = &quot;con&quot;;
		case 3: skillAbility = &quot;int&quot;;
		case 4: skillAbility = &quot;wis&quot;;
		case 5: skillAbility = &quot;cha&quot;
	]
}]
[h: log.debug (&quot;skillAbility: &quot; + skillAbility)]
[h: abilityBonusName = skillAbility + &quot;Bonus&quot;]
[h: skillBonus = json.path.read (abilities, abilityBonusName)]
[h: log.debug (&quot;skill bonus: &quot; + skillBonus)]

&lt;!-- Now determine proficiency --&gt;
&lt;!-- If background or class provided proficiency, its set in the skill already --&gt;
[h: proficient = json.get (skill, &quot;proficient&quot;)]
[h: log.debug (&quot;current proficient: &quot; + proficient)]
[h, if (proficient == &quot;&quot;): proficient = NOT_PROFICIENT]


&lt;!-- bonuses may override this --&gt;
[h: profOverride = json.path.read (skill, &quot;bonuses[*].[?(@.typeId == &quot; + PROF_LEVEL + &quot;)]&quot;)]
[h, if (!json.isEmpty (profOverride)), code: {
	[h: profValue = json.path.read (profOverride, &quot;[0].value&quot;)]
	[h, switch (profValue):
		case 1: proficient = NOT_PROFICIENT;
		case 2: proficient = HALF_PROFICIENT;
		case 3: proficient = FULL_PROFICIENT;
		case 4: proficient = EXPERT_PROFICIENT
	]
}]

&lt;!-- determine the actual bonus --&gt;
[h: proficiencyBonus = dndb_getProficiencyBonus (toon)]
[h: log.debug (&quot;proficient after bonus: &quot; + proficient + &quot;; bonus: &quot; + proficiencyBonus)]

&lt;!-- So we made constants for reasons, but maptool hates freedom --&gt;
[h, switch (proficient):
	case &quot;not&quot;: proficiencyBonus = 0;
	case &quot;half&quot;: proficiencyBonus = round (math.floor (proficiencyBonus / 2));
	case &quot;proficient&quot;: proficiencyBonus;
	case &quot;expert&quot;: proficiencyBonus = proficiencyBonus * 2
]
[h: log.debug (&quot;Proficiency: &quot; + proficient + &quot; :: &quot; + proficiencyBonus)]

&lt;!-- Next, sniff out bonus values --&gt;
[h: miscBonusArry = json.path.read (skill, &quot;bonuses[*].[?(@.typeId == &quot; + MISC_BONUS + &quot;)][&apos;value&apos;]&quot;)]
[h, if (!json.isEmpty (miscBonusArry)): miscBonus = json.get (miscBonusArry, 0); miscBonus = 0]
[h: magicBonusArry = json.path.read (skill, &quot;bonuses[*].[?(@.typeId == &quot; + MAGIC_BONUS + &quot;)][&apos;value&apos;]&quot;)]
[h, if (!json.isEmpty (magicBonusArry)): magicBonus = json.get (magicBonusArry, 0); magicBonus = 0]

&lt;!-- and finally, the arbitrary override value --&gt;
[h: overrideBonusArry = json.path.read (skill, &quot;bonuses[*].[?(@.typeId == &quot; + OVERRIDE + &quot;)][&apos;value&apos;]&quot;)]

[h, if (!json.isEmpty (overrideBonusArry)): override = json.get (overrideBonusArry, 0); override = &quot;&quot;]
[h: log.debug (&quot;overrideBonusArry :&quot; + overrideBonusArry + &quot; :: override = &quot; + override)]
&lt;!-- enough lookin, get to doin --&gt;
[h, if (override == &quot;&quot;): totalBonus = skillBonus + proficiencyBonus + miscBonus + magicBonus; totalBonus = override]
&lt;!-- rewrite the bonus arry --&gt;
[h: bonusArry = json.append (&quot;&quot;,
				json.set (&quot;&quot;, &quot;type&quot;, &quot;Magic&quot;, &quot;value&quot;, magicBonus),
				json.set (&quot;&quot;, &quot;type&quot;, &quot;Misc&quot;, &quot;value&quot;, miscBonus),
				json.set (&quot;&quot;, &quot;type&quot;, &quot;Proficiency&quot;, &quot;value&quot;, proficiencyBonus),
				json.set (&quot;&quot;, &quot;type&quot;, &quot;Ability&quot;, &quot;value&quot;, skillBonus),
				json.set (&quot;&quot;, &quot;type&quot;, &quot;Override&quot;, &quot;value&quot;, override))]
[h, if (proficient == &quot;not&quot;): proficient = &quot;&quot;]
[h: skill = json.set (skill, &quot;proficient&quot;, proficient, &quot;bonuses&quot;, bonusArry, &quot;totalBonus&quot;, totalBonus)]
[h: log.debug (json.indent(skill))]
[h: macro.return = skill]

</command>
        <label>dndb_transformSkill</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>arg(0) = toon
arg(1) = skill (the initial generated version by dndb_getSkill)

Callers not dndb_getSkill are unlikely to need this method.</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>36</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>0988083c-41aa-4d33-a8cf-64f129cfc5d0</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>36</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- Instead of the usual arg array, try a json obj --&gt;

[h: filterObj = arg(0)]
[h: object = json.get (filterObj, &quot;object&quot;)]
[h: property = json.get (filterObj, &quot;property&quot;)]
[h: even = 1]

[h: filterObj = json.remove (filterObj, &quot;object&quot;)]
[h: filterObj = json.remove (filterObj, &quot;property&quot;)]
&lt;!-- now build the filter --&gt;

[h: rawValues = json.append (&quot;&quot;, &quot;true&quot;, &quot;false&quot;)]

[h: filter = &quot;&quot;]
[h, foreach (field, json.fields (filterObj)), code: {
	&lt;!-- to avoid nesting code, build the filter first, then check if we want it --&gt;
	[h, if (filter == &quot;&quot;): filter = &quot;.[?(&quot;; filter = filter + &quot; &amp;&amp; &quot;]
	[h: rawValue = json.get (filterObj, field)]
	&lt;!-- This is fucking stupid. Ask me why, sometime --&gt;
	[h, if (json.contains (rawValues, rawValue) &gt; 0 || isNumber (rawValue) &gt; 0): 
		filterToken = &quot;@.&quot; + field + &quot; == &quot; + rawValue;
		filterToken = &quot;@.&quot; + field + &quot; == &quot; + &quot;&apos;&quot; + rawValue + &quot;&apos;&quot;]

	[h: filter = filter + filterToken]
}]
[h: filter = filter + &quot;)]&quot;]
&lt;!-- close the filter --&gt;
[h, if (property != &quot;&quot;): filter = filter + &quot;[&apos;&quot; + property + &quot;&apos;]&quot;]
[h: log.debug (&quot;filter: &quot; + filter)]

[h: macro.return = json.path.read (object, filter)]
</command>
        <label>dndb_searchJsonObject</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Performs searches against a JSON object as would json.path.read does. Takes a JSON argument:

arg(0) = 
{
  &quot;object&quot;: &quot;toon&quot;,
  &quot;property&quot;: &quot;fixedValue&quot;,
  &quot;subType&quot;: &quot;ability-checks&quot;,
  &quot;type&quot;: &quot;expertise&quot;
}

Within the JSON, the &quot;object&quot; parameter is required. It can be a full character JSON or a sub-section.

&quot;property&quot; is a reserved parameter that indicates the values to return. If &quot;property&quot; is not provided, the full entity is returned for each match.

All other key-value pairs are used as search terms.</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>37</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>05f2a6d6-72a7-47a0-aeaa-45ef54775a55</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>37</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>[h: toon = arg(0)]
&lt;!-- But we don&apos;t look outside of the data.modifiers object, so how? --&gt;
[h: savesMap = json.append (&quot;&quot;,
			json.set (&quot;&quot;, &quot;name&quot;, &quot;Strength&quot;, &quot;valueId&quot;, &quot;1&quot;, &quot;abilityBonus&quot;, &quot;strBonus&quot;),
			json.set (&quot;&quot;, &quot;name&quot;, &quot;Dexterity&quot;, &quot;valueId&quot;, &quot;2&quot;, &quot;abilityBonus&quot;, &quot;dexBonus&quot;),
			json.set (&quot;&quot;, &quot;name&quot;, &quot;Constitution&quot;, &quot;valueId&quot;, &quot;3&quot;, &quot;abilityBonus&quot;, &quot;conBonus&quot;),
			json.set (&quot;&quot;, &quot;name&quot;, &quot;Intelligence&quot;, &quot;valueId&quot;, &quot;4&quot;, &quot;abilityBonus&quot;, &quot;intBonus&quot;),
			json.set (&quot;&quot;, &quot;name&quot;, &quot;Wisdom&quot;, &quot;valueId&quot;, &quot;5&quot;, &quot;abilityBonus&quot;, &quot;wisBonus&quot;),
			json.set (&quot;&quot;, &quot;name&quot;, &quot;Charisma&quot;, &quot;valueId&quot;, &quot;6&quot;, &quot;abilityBonus&quot;, &quot;chaBonus&quot;)
			)
]
[h, if (json.length (macro.args) &gt; 1): 
	saveNames = json.append (&quot;&quot;, arg(1));
	saveNames = json.append (&quot;&quot;, &quot;Strength&quot;, &quot;Dexterity&quot;, &quot;Constitution&quot;,
					&quot;Intelligence&quot;, &quot;Wisdom&quot;, &quot;Charisma&quot;)
]

&lt;!-- Saving throws are about as stupid as skills, but here we go --&gt;
[h: allProfValue = 1]
[h: searchArgs = json.set (&quot;&quot;, &quot;object&quot;, toon,
							&quot;property&quot;, &quot;type&quot;,
							&quot;subType&quot;, &quot;saving-throws&quot;,
							&quot;type&quot;, &quot;half-proficiency&quot;)]
[h: halfArry = dndb_searchGrantedModifiers (searchArgs)]
[h, if ( json.length (halfArry) &gt; 0): allProfValue = 2]

[h: searchArgs = json.set (searchArgs, &quot;type&quot;, &quot;proficiency&quot;)]
[h: fullArry = dndb_searchGrantedModifiers (searchArgs)]
[h, if (json.length (fullArry) &gt; 0): allProfValue = 3]

[h: searchArgs = json.set (searchArgs, &quot;type&quot;, &quot;expertise&quot;)]
[h: expertArry = dndb_searchGrantedModifiers (searchArgs)]
[h, if (json.length (expertArry) &gt; 0): allProfValue = 4]

&lt;!-- all Saves bonus --&gt;
[h: searchArgs = json.set (searchArgs, 
							&quot;property&quot;, &quot;fixedValue&quot;,
							&quot;subType&quot;, &quot;saving-throws&quot;,
							&quot;type&quot;, &quot;bonus&quot;)]

[h: allSaveBonusArry = dndb_searchGrantedModifiers (searchArgs)]
[h: log.debug (&quot;allSaveBonusArry: &quot; + json.indent (allSaveBonusArry))]
[h: finalSaves = &quot;[]&quot;]

[h, foreach (saveName, saveNames), code: {
	[h: valueIdArry = dndb_searchJsonObject (json.set (&quot;&quot;,
						&quot;object&quot;, savesMap,
						&quot;name&quot;, saveName,
						&quot;property&quot;, &quot;valueId&quot;))]
	[h: valueId = json.get (valueIdArry, 0))]
	[h: searchSaveName = lower (saveName + &quot;-saving-throws&quot;)]
	[h: log.debug (&quot;searchSaveName: &quot; + searchSaveName)]

	&lt;!-- first proficiencies --&gt;
	[h: profValue = 1]
	[h: searchArgs = json.set (&quot;&quot;, &quot;object&quot;, toon,
							&quot;subType&quot;, searchSaveName,
							&quot;type&quot;, &quot;half-proficiency&quot;,
							&quot;property&quot;, &quot;type&quot;)]
	[h: halfArry = dndb_searchGrantedModifiers (searchArgs)]
	[h: log.debug (&quot;halfArry: &quot; + json.indent (halfArry))]
	[h, if (json.length (halfArry) &gt; 0): profValue = 2]

	[h: searchArgs = json.set (searchArgs, &quot;type&quot;, &quot;proficiency&quot;)]
	[h: fullArry = dndb_searchGrantedModifiers (searchArgs)]
	[h: log.debug (&quot;fullArry: &quot; + json.indent (fullArry))]
	[h, if (json.length (fullArry) &gt; 0): profValue = 3]

	[h: searchArgs = json.set (searchArgs, &quot;type&quot;, &quot;expertise&quot;)]
	[h: expertArry = dndb_searchGrantedModifiers (searchArgs)]
	[h: log.debug (&quot;expertArry: &quot; + json.indent (expertArry))]
	[h, if (json.length (expertArry) &gt; 0): profValue = 4]

	[h: bonusArry = &quot;[]&quot;]
	&lt;!-- bonuses array --&gt;
	[h: searchArgs = json.set (searchArgs, &quot;subType&quot;, searchSaveName,
							&quot;property&quot;, &quot;value&quot;,
							&quot;type&quot;, &quot;bonus&quot;)]
	[h: saveBonusArry = dndb_searchGrantedModifiers (searchArgs)]
	[h: log.debug (&quot;saveBonusArry: &quot; + json.indent (saveBonusArry))]
	
	&lt;!-- character choices; These are not found under data.modifiers, so use the generic searchJsonObject --&gt;
	&lt;!-- override --&gt;
	[h: searchArgs = json.set (&quot;&quot;, &quot;object&quot;, json.path.read (toon, &quot;data.characterValues&quot;),
							&quot;typeId&quot;, &quot;38&quot;,
							&quot;property&quot;, &quot;value&quot;,
							&quot;valueId&quot;, valueId)]
	[h: overrideArry = dndb_searchJsonObject (searchArgs)]

	&lt;!-- Magic Bonus --&gt;
	[h: searchArgs = json.set (searchArgs, &quot;typeId&quot;, &quot;40&quot;)]
	[h: magicArry = dndb_searchJsonObject (searchArgs)]
	[h: log.debug (&quot;magicArry: &quot; + json.indent (magicArry))]

	&lt;!-- Misc Bonus --&gt;
	[h: searchArgs = json.set (searchArgs, &quot;typeId&quot;, &quot;39&quot;)]
	[h: miscArry = dndb_searchJsonObject (searchArgs)]
	[h: log.debug (&quot;miscArry: &quot; + json.indent (miscArry))]

	&lt;!-- Proficiency (character choice overrides) --&gt;
	[h: searchArgs = json.set (searchArgs, &quot;typeId&quot;, &quot;41&quot;)]
	[h: profArry = dndb_searchJsonObject (searchArgs)]
	[h: log.debug (&quot;profArry: &quot; + json.indent (profArry))]
	
	[h: choiceProfValue = 0]
	[h, if (json.length(profArry) &gt; 0): choiceProfValue = json.get (profArry, 0)]


	&lt;!-- build the save --&gt;
	[h: abilities = dndb_getAbilities (toon)]
	[h: bonusArry = &quot;&quot;]
	[h: totalBonus = 0]

	&lt;!-- determine ability bonus --&gt;
	[h: abilitySearchResult = dndb_searchJsonObject (json.set (&quot;&quot;,
									&quot;object&quot;, savesMap,
									&quot;name&quot;, saveName,
									&quot;property&quot;, &quot;abilityBonus&quot;))]
	[h: log.debug (&quot;abilitySearchResult: &quot; + abilitySearchResult)]
	[h: abilityBonusName = json.get (abilitySearchResult, 0)]
	[h: abilityBonus = json.get (abilities, abilityBonusName)]
	[h: bonusArry = json.append (bonusArry, json.set (&quot;&quot;, &quot;type&quot;, &quot;Ability&quot;, &quot;value&quot;, abilityBonus))]
	[h: totalBonus = totalBonus + abilityBonus]

	&lt;!-- determine proficiency value --&gt;
	[h, if (choiceProfValue &gt; 0): actualProfValue = choiceProfValue;
								actualProfValue = round (math.max (profValue, allProfValue))]

	[h, switch (actualProfValue), code:
		case 1: {
			[h: profBonus = 0]
			[h: proficient = &quot;&quot;]
		};
		case 2: {
			[h: profBonus = round (math.floor (profBonus / 2))]
			[h: proficient = &quot;half&quot;]
		};
		case 3: {
			[h: profBonus = dndb_getProficiencyBonus (toon)]
			[h: proficient = &quot;proficient&quot;]
		};
		case 4: {
			[h: profBonus = profBonus * 2]
			[h: proficient = &quot;expert&quot;]
		}
	]
	[h: totalBonus = totalBonus + profBonus]

	[h: savingThrow = json.set (&quot;&quot;, &quot;name&quot;, saveName,
								&quot;proficient&quot;, proficient,
								&quot;valueId&quot;, valueId)]
	[h: bonusArry = json.append (bonusArry, json.set (&quot;&quot;, &quot;type&quot;, &quot;Proficiency&quot;, &quot;value&quot;, profBonus))]
	
	&lt;!-- class, background, item &quot;bonus&quot; bonuses --&gt;
	[h: bonus = 0]
	[h, foreach (saveBonus, saveBonusArry): bonus = bonus + saveBonus]
	[h, foreach (allSaveBonus, allSaveBonusArry): bonus = bonus + allSaveBonus]
	[h: bonusArry = json.append (bonusArry, json.set (&quot;&quot;, &quot;type&quot;, &quot;Bonus&quot;, &quot;value&quot;, bonus))]
	[h: totalBonus = totalBonus + bonus]

	&lt;!-- character choices bonuses (magic and misc) --&gt;
	[h: totalMagicBonus = 0]
	[h, foreach (magicBonus, magicArry): totalMagicBonus = totalMagicBonus + magicBonus]
	[h: bonusArry = json.append (bonusArry, json.set (&quot;&quot;, &quot;type&quot;, &quot;Magic&quot;, &quot;value&quot;, totalMagicBonus))]
	[h: totalBonus = totalBonus + totalMagicBonus]

	[h: totalMiscBonus = 0]
	[h, foreach (miscBonus, miscArry): totalMiscBonus = totalMiscBonus + miscBonus]
	[h: bonusArry = json.append (bonusArry, json.set (&quot;&quot;, &quot;type&quot;, &quot;Misc&quot;, &quot;value&quot;, totalMiscBonus))]
	[h: totalBonus = totalBonus + totalMiscBonus]

	&lt;!-- finally, the override --&gt;
	[h: overrideValue = &quot;&quot;]
	[h, if (json.length (overrideArry) &gt; 0), code: {
		&lt;!-- should only be one value --&gt;
		[h: overrideValue = json.get (overrideArry, 0)]
		[h: totalBonus = overrideValue]
	}]
	[h: bonusArry = json.append (bonusArry, json.set (&quot;&quot;, &quot;type&quot;, &quot;Override&quot;, &quot;value&quot;, overrideValue))]

	[h: savingThrow = json.set (savingThrow, &quot;totalBonus&quot;, totalBonus,
									&quot;bonuses&quot;, bonusArry)]
	[h: finalSaves = json.append (finalSaves, savingThrow)]							
}]

[h: macro.return = finalSaves]


</command>
        <label>dndb_getSavingThrow</label>
        <group>Character</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip></toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
    <entry>
      <int>38</int>
      <net.rptools.maptool.model.MacroButtonProperties>
        <macroUUID>f83d8d11-1eba-481d-afd9-873b9b849271</macroUUID>
        <saveLocation>Token</saveLocation>
        <index>38</index>
        <colorKey>default</colorKey>
        <hotKey>None</hotKey>
        <command>&lt;!-- Bug: Doesnt account for saves when  &quot;availableToMulticlass&quot;: false --&gt;
&lt;!-- Not so simple. Cant just look for availabletomulticlass false. we have to join granted results WITH --&gt;
&lt;!-- the that value being false WITH their actual mult-classed classes --&gt;

&lt;!-- Instead of the usual arg array, try a json obj --&gt;
[h: filterObj = arg(0)]
[h: toon = json.get (filterObj, &quot;object&quot;)]
[h: property = json.get (filterObj, &quot;property&quot;)]

&lt;!-- filterObj is only filter terms. Well provide our own object and stuff property back in as needed --&gt;
[h: filterObj = json.remove (filterObj, &quot;object&quot;)]
[h: filterObj = json.remove (filterObj, &quot;property&quot;)]

[h: resultArry = &quot;&quot;]

&lt;!-- Start with item bonuses. Thats why were here anyways. --&gt;
&lt;!-- Item bonuses are listed in the modifiers object, but should not apply if the associated object isnt --&gt;
&lt;!-- equipped. This first retreives a list of equipped items and builds an arry of ids. Then full modifier --&gt;
&lt;!-- objects are pulled from items and their componentIds checked against equipped ids --&gt;

[h: items = json.path.read (toon, &quot;data.inventory&quot;)]
[h: equippedItems = json.path.read (items, &quot;.[?(@.equipped == true)]&quot;)]
[h: equippedItemIds = json.path.read (equippedItems, &quot;[*].definition.id&quot;)]
[h: log.debug (&quot;Equipped items: &quot; + equippedItemIds)]

&lt;!-- now search for modifications from just item and compare componentId with equipped ids --&gt;
[h: itemSearchArg = json.set (filterObj, &quot;object&quot;, json.path.read (toon, &quot;data.modifiers.item&quot;))]
[h: itemSearchResults = dndb_searchJsonObject (itemSearchArg)]
[h: log.debug (&quot;Item search results: &quot; + json.indent (itemSearchResults))]
[h: equippedModifiers = &quot;[]&quot;]
[h, foreach (itemModification, itemSearchResults), code: {
	[h: componentId = json.get (itemModification, &quot;componentId&quot;)]
	[h, if (json.contains (equippedItemIds, componentId) &gt; 0), code: {
		[h: log.debug (&quot;Modification is equipped&quot;)]
		&lt;!-- marshall the result, either scalar or object, into a list --&gt;
		[h, if (property != &quot;&quot;): itemModification = json.path.read (itemModification, property);
								 itemModification = json.append (&quot;&quot;, itemModification)]
		[h: equippedModifiers = json.merge (equippedModifiers, itemModification)]
	}]
}]

&lt;!-- whatevers in equippedModifiers is what we want --&gt;
[h: resultArry = json.merge (resultArry, equippedModifiers)]

&lt;!-- everything else gets the same treatement --&gt;
&lt;!-- Not so fast! Class modifiers have to check for availableToMultiClass --&gt;
[h: nonItems = json.append (&quot;&quot;, &quot;background&quot;, &quot;class&quot;, &quot;condition&quot;, &quot;feat&quot;, &quot;race&quot;)]

[h, foreach (classification, nonItems), code: {
	[h: searchObjectPath = &quot;data.modifiers.&quot; + classification]
	[h: searchObject = json.path.read (toon, searchObjectPath)]
	[h: subSearchArg = json.set (filterObj, &quot;object&quot;, searchObject, &quot;property&quot;, property)]

	[h: subSearchResults = dndb_searchJsonObject (subSearchArg)]
	[h: log.debug (&quot;subSearchResults: &quot; + subSearchResults)]
	[h, if (json.length (subSearchResults) &gt; 0): resultArry = json.merge (resultArry, subSearchResults)]
}]

[h: log.debug (resultArry)]
[h: macro.return = resultArry]</command>
        <label>dndb_searchGrantedModifiers</label>
        <group>Utility</group>
        <sortby></sortby>
        <autoExecute>true</autoExecute>
        <includeLabel>false</includeLabel>
        <applyToTokens>false</applyToTokens>
        <fontColorKey>black</fontColorKey>
        <fontSize>1.00em</fontSize>
        <minWidth></minWidth>
        <maxWidth></maxWidth>
        <allowPlayerEdits>false</allowPlayerEdits>
        <toolTip>Searches the data.modifier object for all modifiers granted by classes, backgrounds, feats, conditions, race, and equipped items.

arg(0) = 
{
  &quot;object&quot;: &quot;toon&quot;,
  &quot;property&quot;: &quot;fixedValue&quot;,
  &quot;subType&quot;: &quot;ability-checks&quot;,
  &quot;type&quot;: &quot;expertise&quot;
}

Within the JSON, the &quot;object&quot; parameter is required. It must be a full character JSON.

&quot;property&quot; is a reserved parameter that indicates the values to return. If &quot;property&quot; is not provided, the full entity is returned for each match.

All other key-value pairs are used as search terms.</toolTip>
        <displayHotKey>true</displayHotKey>
        <commonMacro>false</commonMacro>
        <compareGroup>true</compareGroup>
        <compareSortPrefix>true</compareSortPrefix>
        <compareCommand>true</compareCommand>
        <compareIncludeLabel>true</compareIncludeLabel>
        <compareAutoExecute>true</compareAutoExecute>
        <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
      </net.rptools.maptool.model.MacroButtonProperties>
    </entry>
  </macroPropertiesMap>
  <speechMap/>
</net.rptools.maptool.model.Token>
