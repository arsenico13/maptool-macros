<net.rptools.maptool.model.MacroButtonProperties>
  <macroUUID>b493d185-a38d-410d-8fb3-89abf758da0f</macroUUID>
  <saveLocation>GlobalPanel</saveLocation>
  <index>21</index>
  <colorKey>red</colorKey>
  <hotKey>None</hotKey>
  <command>&lt;!-- Bode Make Attack --&gt;
&lt;!-- Constants --&gt;
[h: ATTACK_JSON = &quot;attackJSON&quot;]
[h: NAME = &quot;name&quot;]
[h: ATK_BONUS = &quot;atkBonus&quot;]
[h: DMG_BONUS = &quot;dmgBonus&quot;]
[h: DMG_DIE = &quot;dmgDie&quot;]
[h: DMG_DICE = &quot;dmgDice&quot;]
[h: CRIT_BONUS_DICE = &quot;critBonusDice&quot;]
[h: DMG_TYPE = &quot;dmgType&quot;]
[h: DMG_BONUS_EXPR = &quot;dmgBonusExpr&quot;]
[h: NEW_ATTACK = &quot;New Attack&quot;]
[h: LAST_ATTACK_SELECTION = &quot;lastAttackSelection&quot;]

&lt;!-- Read attack JSON and prompt for selection --&gt;
[h, if (!isPropertyEmpty (ATTACK_JSON)), code: {
    &lt;!-- Property is populated. Fetch JSON data --&gt;
    [h: attackJson = getProperty(ATTACK_JSON)]
}; {
    &lt;!-- Property is empty, use blank object --&gt;
    [h: attackJson = &quot;&quot;]
}]

[h: arrLen = json.length(attackJson)]
[h, if (arrLen &lt; 1), code: {
    &lt;!-- no attacks found, so create one in the config macro --&gt;
    [h, macro(&quot;Attack Config@global&quot;): &quot;&quot;]
    [h: attackJson = getProperty(ATTACK_JSON)]
}; {
    &lt;!-- no-op --&gt;
}]

&lt;!-- Build an attack list to pick from --&gt;
[h: attackList = &quot;&quot;]
[h, foreach (attack, attackJson): attackList = json.append(attackList, json.get(attack, NAME))]

&lt;!-- Locate the index of the last selection to make it the default selection --&gt;
[h: lastSelection = getProperty(LAST_ATTACK_SELECTION)]
[h: selectedIndex = json.indexOf(attackList, lastSelection)]
[h: selectedIndex = if (selectedIndex &lt; 0, 0, selectedIndex)]

&lt;!-- User Input --&gt;
[h,if (isPropertyEmpty(&quot;bonusAttackExpression&quot;)): bonusAttackExpression = &quot;+0&quot;; bonusAttackExpression = getProperty(&quot;bonusAttackExpression&quot;)]
[h,if (isPropertyEmpty(&quot;bonusAttackReason&quot;)): bonusAttackReason = &quot;-&quot;; bonusAttackReason = getProperty(&quot;bonusAttackReason&quot;)]
[h,if (isPropertyEmpty(&quot;applyBonusAttack&quot;)): applyBonusAttack = &quot;0&quot;; applyBonusAttack = getProperty(&quot;applyBonusAttack&quot;)]

[h: abort( input(
    &quot;selectedAttack | &quot; + json.toList(attackList) + &quot; | Select Attack | list | value=string select=&quot; + selectedIndex,
    &quot;bonusAttackExpression|&quot; + bonusAttackExpression + &quot;|Bonus Attack Expression|text&quot;,
    &quot;bonusAttackReason|&quot; + bonusAttackReason + &quot;|Bonus Attack Reason: (e.g. Bless, Inspiration)|text&quot;,
    &quot;applyBonus|&quot;+applyBonusAttack+&quot;|Apply Bonus|check&quot;,
    &quot;advantageDisadvantage|None,Advantage,Disadvantage|Advantage/Disadvantage|list|value=string&quot;
))]

&lt;!-- Save the selection for next execution as the default selection --&gt;
[h: setProperty(LAST_ATTACK_SELECTION, selectedAttack)]
[h,if(applyBonus == 1),CODE:
{
    [setProperty(&quot;bonusAttackExpression&quot;, bonusAttackExpression)]
    [setProperty(&quot;bonusAttackReason&quot;, bonusAttackReason)]
    [setProperty(&quot;applyBonusAttack&quot;, applyBonusAttack)]
}]

&lt;!-- Attack selected! Fetch the JSON for the selected attack. --&gt;
[r, foreach (attack, attackJson), code: {
    [h: attackName = json.get(attack, NAME)]
    [h, if (attackName == selectedAttack), code: {
        [cfgAttack = attack]
    };{ 0 }]
}]

&lt;!-- transfer json properties to input vars --&gt;
[h: attackBonus = json.get(cfgAttack, ATK_BONUS)]
[h: dmgBonus = json.get(cfgAttack, DMG_BONUS)]
[h: dmgDie = json.get(cfgAttack, DMG_DIE)]
[h: dmgNumDice = json.get(cfgAttack, DMG_DICE)]
[h: attackName = json.get(cfgAttack, NAME)]
[h: critBonus = json.get(cfgAttack, CRIT_BONUS_DICE)]
[h: dmgType = json.get(cfgAttack, DMG_TYPE)]
[h: dmgBonusExpr = json.get(cfgAttack, DMG_BONUS_EXPR)]

&lt;!-- Roll attack dice (always roll two, determine if advantage or disadvantage applies after --&gt;
&lt;!-- Unlike dmg rolls that use a full text expression, attack is done in discrete steps to determine criticals --&gt;
[h: attack = 1d20]
[h: attack2 = 1d20]

&lt;!-- Calculate the correct attack roll --&gt;
[h: realAttack = attack]
[h,if (advantageDisadvantage == &quot;Advantage&quot;): realAttack = max(attack, attack2)]
[h,if (advantageDisadvantage == &quot;Disadvantage&quot;): realAttack = min(attack, attack2)]

&lt;!-- Apply critical --&gt;
[h,if (realAttack == 20): dmgNumDice = (dmgNumDice * 2) + critBonus]

&lt;!-- Roll damage --&gt;
[h: dmgExpression = dmgNumDice + &quot;d&quot; + dmgDie + &quot; + &quot; + dmgBonus]
[h: noDmgExpression = json.equals(dmgBonusExpr, &quot;&quot;) + json.equals(dmgBonusExpr, 0)]
[h: dmgExpression = if (noDmgExpression &gt; 0, dmgExpression, dmgExpression + &quot; + &quot; + dmgBonusExpr)]
[h: dmg = eval(dmgExpression)]
[h,if(applyBonus != 0),CODE:
{
    [bless = eval(&quot;0 + &quot; + bonusAttackExpression)]
    [bonusAttackReason = &quot; &quot; + bonusAttackReason]
};
{
    [bless = 0]
    [bonusAttackExpression = &quot;&quot;]
    [bonusAttackReason = &quot;&quot;]
}]


&lt;!-- Build the message --&gt;
[h: critString=&quot;&lt;font color=&apos;red&apos;&gt;&lt;i&gt;CRITICAL&lt;/i&gt;&lt;/font&gt; &quot;]
[h: atkString = &quot;&lt;b&gt;&quot;]
[h: atk2String = &quot;&lt;b&gt;&quot;]
[h,if(attack == 20): atkString = atkString + critString]
[h,if(attack2 == 20): atk2String = atk2String + critString]

[h,if(advantageDisadvantage != &quot;None&quot;): realAtkString = &quot;&lt;b&gt;&quot; + realAttack + &quot;&lt;/b&gt;&quot;]
[h: attackTotal = attack + attackBonus + bless]
[h: atkString = atkString + attackTotal + &quot;&lt;/b&gt;&quot;]
[h: attack2Total = attack2 + attackBonus + bless]
[h: atk2String = atk2String + attack2Total + &quot;&lt;/b&gt;&quot;]
[h: realAttack = realAttack + attackBonus + bless]

[h: nameStr = getName() + &quot;: &quot; + attackName + &quot;&lt;br&gt;(&quot; + dmgType + &quot;)&lt;br&gt;&lt;br&gt;&quot;]
[h: atkStr = &quot;Attack (1d20 + &quot; + attackBonus + &quot;): &quot; + atkString + &quot;&lt;br&gt;&quot;]
[h,if(advantageDisadvantage != &quot;None&quot;),CODE:
{
    [atkStr = atkStr + advantageDisadvantage + &quot;: &quot; + atk2String]
    [atkStr = atkStr + &quot;&lt;br&gt;&lt;br&gt;Actual Attack: &lt;b&gt;&quot; + realAtkString]
    [atkStr = atkStr + bonusAttackReason + &quot;&lt;/b&gt;&lt;br&gt;&quot;]
};
{
    [atkStr = &quot;Attack (1d20 + &quot; + attackBonus +&quot;): &lt;b&gt;&quot; + atkString]
    [atkStr = atkStr + bonusAttackReason + &quot;&lt;/b&gt;&lt;br&gt;&quot;]
}]
[h: dmgStr = &quot;Damage (&quot; + dmgExpression + &quot;): &quot; + dmg]

[r: nameStr]
[r: atkStr]
[r: dmgStr]</command>
  <label>Make Attack</label>
  <group>Attack</group>
  <sortby>1</sortby>
  <autoExecute>true</autoExecute>
  <includeLabel>false</includeLabel>
  <applyToTokens>true</applyToTokens>
  <fontColorKey>black</fontColorKey>
  <fontSize>1.00em</fontSize>
  <minWidth>50</minWidth>
  <maxWidth></maxWidth>
  <allowPlayerEdits>true</allowPlayerEdits>
  <toolTip></toolTip>
  <displayHotKey>true</displayHotKey>
  <commonMacro>false</commonMacro>
  <compareGroup>true</compareGroup>
  <compareSortPrefix>true</compareSortPrefix>
  <compareCommand>true</compareCommand>
  <compareIncludeLabel>true</compareIncludeLabel>
  <compareAutoExecute>true</compareAutoExecute>
  <compareApplyToSelectedTokens>true</compareApplyToSelectedTokens>
</net.rptools.maptool.model.MacroButtonProperties>
