[h: args = macro.args]
[h: clientTime = l4m.getClientTime()]
[h: l4m.Constants()]
[h: macroName = json.get (args, "name")]
[h: retVal = json.get (args, "return")]
[h: tokenName = json.get (args, "token")]
[h: previousRootLogger = json.get (args, "previousRootLevel")]
[h, if (macroName == "dndb_searchJsonObject"): doBreak = 0; doBreak = 1]
[h, if (previousRootLogger == ""): previousRootLogger = ROOT_LOGGER_WRAPPER_DEFAULT_LEVEL]
[h: category = tokenName + "." + macroName]
[h, if (l4m.isLogLevelEnabled (ENTRY_EXIT_LOG_LEVEL, category, ".entryExit")), code: {
	[exitingMsg = "Exiting " + macroName + ": " + retVal]
	[log.info (category, exitingMsg, ".entryExit")]
}]
[h: setLibProperty (LOGGER_PREFIX + ROOT_LOGGER_CATEGORY + ".level", previousRootLogger, LIB_LOG4MT)]
[h: setLibProperty (COMPILED_LOGGER_PREFIX + ROOT_LOGGER_CATEGORY + ".value", "", LIB_LOG4MT)]
[h: setLibProperty (COMPILED_LOGGER_PREFIX + ROOT_LOGGER_CATEGORY + ".level", "", LIB_LOG4MT)]
[h: setLibProperty (COMPILED_LOGGER_PREFIX + ".value", "", LIB_LOG4MT)]
[h: setLibProperty (COMPILED_LOGGER_PREFIX + ".level", "", LIB_LOG4MT)]
[h: propertyName = l4m.getMeterName(macroName)]
[h: currentValue = getLibProperty (propertyName, LIB_LOG4MT)]
[h: startTime = json.get (currentValue, "startTime")]
[h: totalTime = clientTime - startTime]
[h: meters = json.get (currentValue, "meters")]
[h: meters = json.append (meters, totalTime)]
[h: currentValue = json.set (currentValue, "meters", meters)]

[h: setLibProperty (propertyName, currentValue, LIB_LOG4MT)]

[h: callStack = getLibProperty (CALL_STACK, LIB_LOG4MT)]
[h: lastCall = json.get (callStack, json.length (callStack) - 1)]
[h, if (lastCall != MACRO_ABORT): 
	callStack = json.remove (callStack, json.length (callStack) - 1)]
[h: setLibProperty (CALL_STACK, callStack, LIB_LOG4MT)]

[h: abort (lastCall != MACRO_ABORT)]